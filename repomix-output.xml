This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  .worker-tracking/
    ad82ed6c/
      hivemind_find.marker
      hivemind_store.marker
      swarmmail_init.marker
src/
  legal_anki/
    llm/
      __init__.py
      openai_client.py
      protocol.py
    prompts/
      __init__.py
      system.py
    __init__.py
    anki_connect.py
    config.py
    exporters.py
    generator.py
    models.py
    serializers.py
    utils.py
    validators.py
tests/
  conftest.py
  test_exporters.py
  test_llm_client.py
  test_utils.py
  test_validators.py
.env.example
.python-version
analisecoderabbit_debug.md
main.py
PRD.md
pyproject.toml
README.md
ROADMAP.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/.worker-tracking/ad82ed6c/hivemind_find.marker">
2026-02-08T08:39:36.083Z
</file>

<file path=".claude/.worker-tracking/ad82ed6c/hivemind_store.marker">
2026-02-08T08:40:40.300Z
</file>

<file path=".claude/.worker-tracking/ad82ed6c/swarmmail_init.marker">
2026-02-08T08:41:29.845Z
</file>

<file path="analisecoderabbit_debug.md">
Starting CodeRabbit review in plain text mode...

Connecting to review service
Setting up
Analyzing
Reviewing

============================================================================
File: tests/test_validators.py
Line: 42
Type: nitpick

Prompt for AI Agent:
In @tests/test_validators.py at line 42, Multiple tests duplicate the same local import "from legal_anki.models import AnkiCard"; move that import to the top-level imports of the module (alongside the other imports) and remove the repeated in-function imports inside the test functions (the local occurrences referencing AnkiCard) so all tests use the single top-level AnkiCard import.
</file>

<file path="ROADMAP.md">
# üó∫Ô∏è Roadmap LegalAnki

Este documento descreve a vis√£o de futuro do **LegalAnki** e os marcos planejados para transformar o estudo jur√≠dico em uma experi√™ncia automatizada e de alta performance.

---

## üöÄ Fase 1: Estabiliza√ß√£o e UX (v1.x)

_Foco: Robustez do sistema atual e facilidade de uso via CLI._

- [x] **Melhorias CSV:** Valida√ß√£o, sanitiza√ß√£o e logging robusto.
- [x] **Interface CLI:** Execu√ß√£o via terminal com suporte a arquivos e texto.
- [ ] **Templates Premium:** Implementa√ß√£o de CSS moderno e responsivo para os modelos de cards no Anki.
- [ ] **Integra√ß√£o Anki-Connect:**
  - Auto-sincroniza√ß√£o (`sync`) ap√≥s exporta√ß√£o bem-sucedida.
  - Verifica√ß√£o de exist√™ncia de decks e modelos antes da gera√ß√£o.
- [ ] **Documenta√ß√£o:** Guia completo de instala√ß√£o e exemplos de uso em casos reais (Direito Administrativo, Penal, etc).

---

## üì¶ Fase 2: Multim√≠dia e Novos Formatos (v2.x)

_Foco: Expans√£o de funcionalidades e suporte nativo a arquivos Anki._

- [ ] **Exporta√ß√£o APKG Nativa:**
  - Suporte completo a modelos customizados sem depend√™ncia externa de importa√ß√£o.
  - Suporte a inclus√£o de m√≠dia (imagens e √°udio) via `genanki.Package.media_files`.
- [ ] **Novos Tipos de Cards:**
  - `Cloze` (Omiss√£o de Palavras) para memoriza√ß√£o de textos de lei seca.
  - Cards de "Vem na Prova" com estat√≠sticas de incid√™ncia (extra√≠das via LLM).
- [ ] **Parsing Inteligente:**
  - Extra√ß√£o de texto diretamente de PDFs de julgados (Informativos STF/STJ) e Leis.
  - Limpeza de "ru√≠do" jur√≠dico (cabe√ßalhos, rodap√©s) antes da gera√ß√£o.

---

## üåê Fase 3: Ecossistema e Interface (v3.x)

_Foco: Escala, colabora√ß√£o e facilidade multiplataforma._

- [ ] **Web Review UI:** Interface simples (Streamlit/Vite) para revisar, editar e deletar cards gerados pela IA antes de exportar.
- [ ] **LegalAnki Bot:** Integra√ß√£o com Telegram/Discord para enviar um trecho de lei e receber o arquivo CSV/APKG de volta.
- [ ] **Loja de Prompts Sociais:** Possibilidade de escolher "estilos" de outros usu√°rios (Ex: Prompts focados em Magistratura vs. Delegado).
- [ ] **API P√∫blica:** Wrapper para permitir que outros sites de cursos jur√≠dicos integrem o bot√£o "Gerar Cards" em seus materiais.

---

## ‚úÖ Conclu√≠do

- Estrutura base do projeto (PoC).
- Abstra√ß√£o de LLM (OpenAI/Protocol).
- Valida√ß√£o robusta de Pydantic.
- Exportador CSV v1 sanitizado.
- CLI v1 funcional.

---

> [!TIP]
> Sugest√µes e contribui√ß√µes s√£o bem-vindas! Abra uma issue para discutirmos novas funcionalidades.
</file>

<file path="src/legal_anki/llm/__init__.py">
"""Abstra√ß√£o de clientes LLM para gera√ß√£o de cards."""

from .openai_client import OpenAILLMClient
from .protocol import LLMClient

__all__ = ["LLMClient", "OpenAILLMClient"]
</file>

<file path="src/legal_anki/llm/openai_client.py">
"""Cliente OpenAI com retry usando Tenacity."""

from __future__ import annotations

import logging
from typing import TypeVar

from openai import APIConnectionError, APIError, OpenAI, RateLimitError
from pydantic import BaseModel
from tenacity import (
    Retrying,
    retry_if_exception_type,
    stop_after_attempt,
    wait_exponential_jitter,
)

logger = logging.getLogger(__name__)

T = TypeVar("T", bound=BaseModel)


class OpenAILLMClient:
    """
    Cliente OpenAI com retry e structured outputs.

    Implementa o protocolo LLMClient usando a API da OpenAI com
    retry autom√°tico via Tenacity para erros transientes.
    """

    def __init__(
        self,
        api_key: str,
        model: str = "gpt-4o-2024-08-06",
        max_retries: int = 3,
    ):
        """
        Inicializa o cliente OpenAI.

        Args:
            api_key: Chave da API OpenAI
            model: Modelo a usar (deve suportar structured outputs)
            max_retries: N√∫mero m√°ximo de tentativas em caso de erro
        """
        # Desabilita retry interno do SDK, Tenacity controla
        self.client = OpenAI(api_key=api_key, max_retries=0)
        self.model = model
        self.max_retries = max_retries

    def generate_structured(
        self,
        system_prompt: str,
        user_message: str,
        response_model: type[T],
    ) -> T:
        """
        Gera resposta estruturada com retry autom√°tico.

        Args:
            system_prompt: Prompt do sistema
            user_message: Mensagem do usu√°rio
            response_model: Modelo Pydantic para a resposta

        Returns:
            Inst√¢ncia do response_model parseada

        Raises:
            ValueError: Se o LLM n√£o retornar resposta v√°lida
            APIError: Se todas as tentativas falharem
        """
        retryer = Retrying(
            stop=stop_after_attempt(self.max_retries),
            wait=wait_exponential_jitter(initial=1, max=30, jitter=2),
            retry=retry_if_exception_type(
                (APIError, RateLimitError, APIConnectionError)
            ),
            before_sleep=lambda rs: logger.warning(
                "Retry %d/%d ap√≥s erro: %s",
                rs.attempt_number,
                self.max_retries,
                rs.outcome.exception(),
            ),
            reraise=True,
        )
        return retryer(
            self._call_openai_api, system_prompt, user_message, response_model
        )

    def _call_openai_api(
        self,
        system_prompt: str,
        user_message: str,
        response_model: type[T],
    ) -> T:
        """Chamada direta √† API da OpenAI."""
        logger.debug("Chamando OpenAI API com modelo %s", self.model)

        response = self.client.beta.chat.completions.parse(
            model=self.model,
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_message},
            ],
            response_format=response_model,
        )

        result = response.choices[0].message.parsed

        if not result:
            refusal = response.choices[0].message.refusal
            if refusal:
                raise ValueError(f"LLM recusou gerar resposta: {refusal}")
            raise ValueError("LLM n√£o retornou resposta v√°lida")

        return result
</file>

<file path="src/legal_anki/llm/protocol.py">
"""Protocolo (interface) para clientes LLM."""

from typing import Protocol, TypeVar

from pydantic import BaseModel

T = TypeVar("T", bound=BaseModel)


class LLMClient(Protocol):
    """
    Protocolo para clientes LLM.

    Define a interface que qualquer implementa√ß√£o de cliente LLM deve seguir,
    permitindo troca transparente de providers (OpenAI, Anthropic, local, etc.).
    """

    def generate_structured(
        self,
        system_prompt: str,
        user_message: str,
        response_model: type[T],
    ) -> T:
        """
        Gera uma resposta estruturada usando um modelo Pydantic.

        Args:
            system_prompt: Prompt do sistema com instru√ß√µes
            user_message: Mensagem do usu√°rio com o conte√∫do
            response_model: Classe Pydantic para deserializar a resposta

        Returns:
            Inst√¢ncia do response_model com a resposta parseada
        """
        ...
</file>

<file path="src/legal_anki/prompts/__init__.py">
"""Prompts para gera√ß√£o de cards Anki."""
</file>

<file path="src/legal_anki/prompts/system.py">
"""System prompts para gera√ß√£o de cards Anki."""

LEGAL_BASIS_INSTRUCTION = """
4. SEMPRE inclua o fundamento legal (artigo, inciso, s√∫mula, ADI, ADC, RE, etc.)
   no campo 'extra.fundamento' ou 'extra.fundamento_legal'
   - Para artigos: cite o dispositivo completo (ex: "Art. 5¬∫, LXIII, CF/88")
   - Para s√∫mulas: cite o n√∫mero e tribunal (ex: "S√∫mula Vinculante 11 - STF")
   - Para julgados: cite o n√∫mero do processo quando dispon√≠vel
"""

SYSTEM_PROMPT_BASE = """
Voc√™ √© um especialista em Direito Constitucional brasileiro, professor experiente focado em
prepara√ß√£o para concursos p√∫blicos de alto n√≠vel (Magistratura, MP, Defensoria, Advocacia P√∫blica).

Sua tarefa √© gerar flashcards Anki de alta qualidade seguindo estas regras:

## REGRAS DE CONTE√öDO

1. **Atomicidade**: Cada card deve testar UMA √∫nica ideia ou conceito
   - ‚ùå "Quais s√£o os direitos fundamentais?" (muito amplo)
   - ‚úÖ "Qual √© o fundamento constitucional do direito ao sil√™ncio?" (espec√≠fico)

2. **Clareza**: A pergunta (front) deve ser clara e direta
   - Use linguagem t√©cnica adequada ao n√≠vel de concurso
   - Evite ambiguidades

3. **Completude**: A resposta (back) deve ser concisa mas completa
   - Inclua todos os elementos necess√°rios para uma resposta correta em prova
   - N√£o seja excessivamente longo

{legal_basis_instruction}

## TIPOS DE CARD

### basic
- Pergunta direta no front, resposta no back
- Use para conceitos, defini√ß√µes, distin√ß√µes

### cloze
- Use {{{{c1::texto}}}} para criar lacunas
- Ideal para memoriza√ß√£o de textos legais, requisitos, elementos
- M√°ximo de 2-3 clozes por card

### questao
- Para quest√µes no estilo de concurso (CESPE, FCC, FGV, etc.)
- OBRIGAT√ìRIO: preencher extra.banca, extra.ano quando dispon√≠vel
- Inclua o cargo quando dispon√≠vel

### jurisprudencia
- Para s√∫mulas, teses de repercuss√£o geral, julgados importantes
- OBRIGAT√ìRIO: preencher extra.tribunal, extra.tema
- Inclua extra.data_julgamento quando dispon√≠vel

## FORMATO DE SA√çDA

Cada card deve ter:
- front: texto da pergunta ou cloze
- back: texto da resposta
- card_type: "basic", "cloze", "questao" ou "jurisprudencia"
- tags: lista de tags descritivas (topic ser√° adicionado automaticamente)
- extra: objeto com campos adicionais conforme o tipo

### Campos extra por tipo:
- basic: {{ "fundamento": "..." }} (opcional)
- cloze: {{ "fundamento": "..." }} (opcional)
- questao: {{ "banca": "...", "ano": "...", "cargo": "...", "fundamento": "..." }}
- jurisprudencia: {{ "tribunal": "...", "data_julgamento": "...", "tema": "...", "fundamento_legal": "..." }}

## TAGS

Use tags hier√°rquicas quando apropriado:
- direito_constitucional::direitos_fundamentais::liberdade
- direito_constitucional::organizacao_estado::federalismo

Sempre inclua:
- Tag de dificuldade: "dificuldade::{dificuldade}"
- Tag do tema principal fornecido pelo usu√°rio
"""


def build_system_prompt(
    include_legal_basis: bool = True, difficulty: str = "medio"
) -> str:
    """
    Constr√≥i o system prompt para o LLM.

    Args:
        include_legal_basis: Se True, inclui instru√ß√£o para sempre citar fundamento legal
        difficulty: N√≠vel de dificuldade dos cards (facil, medio, dificil)

    Returns:
        System prompt formatado
    """
    legal_instruction = LEGAL_BASIS_INSTRUCTION if include_legal_basis else ""

    return SYSTEM_PROMPT_BASE.format(
        legal_basis_instruction=legal_instruction,
        dificuldade=difficulty,
    )


# Exemplos de cards para few-shot learning (opcional)
EXAMPLE_CARDS = [
    {
        "front": "Qual √© o fundamento constitucional do direito ao sil√™ncio do preso?",
        "back": "O direito ao sil√™ncio est√° previsto no art. 5¬∫, LXIII, da CF/88, que assegura ao preso o direito de permanecer calado, sendo-lhe garantida a assist√™ncia da fam√≠lia e de advogado.",
        "card_type": "basic",
        "tags": [
            "direito_constitucional",
            "direitos_fundamentais",
            "garantias_processuais",
        ],
        "extra": {"fundamento": "Art. 5¬∫, LXIII, CF/88"},
    },
    {
        "front": "A S√∫mula Vinculante 11 do STF trata de qual tema?",
        "back": "A SV 11 trata do uso de algemas, estabelecendo que s√≥ √© l√≠cito em casos de resist√™ncia, fundado receio de fuga ou perigo √† integridade f√≠sica pr√≥pria ou alheia, devendo ser justificada por escrito.",
        "card_type": "jurisprudencia",
        "tags": [
            "direito_constitucional",
            "sumulas_vinculantes",
            "direitos_fundamentais",
        ],
        "extra": {
            "tribunal": "STF",
            "tema": "Uso de algemas",
            "fundamento_legal": "Art. 5¬∫, III, X e XLIX, CF/88",
        },
    },
]
</file>

<file path="src/legal_anki/__init__.py">
"""LegalAnki - Skill de Gera√ß√£o de Cards Anki para Direito Constitucional."""

__version__ = "1.0.0"
</file>

<file path="src/legal_anki/anki_connect.py">
"""Cliente para integra√ß√£o com AnkiConnect API v6."""

from __future__ import annotations

import logging
from typing import TYPE_CHECKING, Any

import requests

from .config import settings
from .models import get_model_for_card_type
from .serializers import map_card_to_fields

if TYPE_CHECKING:
    from .models import AnkiCard

logger = logging.getLogger(__name__)


class AnkiConnectError(Exception):
    """Erro na comunica√ß√£o com AnkiConnect."""

    pass


class AnkiConnectClient:
    """Cliente para API AnkiConnect v6."""

    def __init__(self, url: str | None = None):
        """
        Inicializa o cliente AnkiConnect.

        Args:
            url: URL do AnkiConnect. Default usa settings.
        """
        self.url = url or settings.anki_connect_url

    def _invoke(self, action: str, **params: Any) -> Any:
        """
        Invoca uma a√ß√£o no AnkiConnect.

        Args:
            action: Nome da a√ß√£o
            **params: Par√¢metros da a√ß√£o

        Returns:
            Resultado da a√ß√£o

        Raises:
            AnkiConnectError: Se houver erro na requisi√ß√£o
        """
        payload = {
            "action": action,
            "version": 6,
            "params": params,
        }

        try:
            response = requests.post(self.url, json=payload, timeout=30)
            response.raise_for_status()
        except requests.RequestException as e:
            raise AnkiConnectError(
                f"Erro de conex√£o com AnkiConnect em {self.url}: {e}"
            ) from e

        result = response.json()

        if result.get("error"):
            raise AnkiConnectError(f"AnkiConnect error: {result['error']}")

        return result.get("result")

    def is_available(self) -> bool:
        """Verifica se o Anki est√° rodando com AnkiConnect."""
        try:
            version = self._invoke("version")
            logger.info(f"AnkiConnect vers√£o {version} dispon√≠vel")
            return True
        except AnkiConnectError:
            return False

    def get_deck_names(self) -> list[str]:
        """Retorna lista de nomes de decks."""
        return self._invoke("deckNames")

    def get_model_names(self) -> list[str]:
        """Retorna lista de nomes de modelos (note types)."""
        return self._invoke("modelNames")

    def create_deck(self, deck_name: str) -> int:
        """
        Cria um novo deck.

        Args:
            deck_name: Nome do deck

        Returns:
            ID do deck criado
        """
        return self._invoke("createDeck", deck=deck_name)

    def add_note(
        self,
        deck_name: str,
        model_name: str,
        fields: dict[str, str],
        tags: list[str],
        allow_duplicate: bool = False,
    ) -> int:
        """
        Adiciona uma nota ao Anki.

        Args:
            deck_name: Nome do deck
            model_name: Nome do modelo/note type
            fields: Dicion√°rio campo -> valor
            tags: Lista de tags
            allow_duplicate: Se True, permite duplicatas

        Returns:
            ID da nota criada
        """
        return self._invoke(
            "addNote",
            note={
                "deckName": deck_name,
                "modelName": model_name,
                "fields": fields,
                "tags": tags,
                "options": {"allowDuplicate": allow_duplicate},
            },
        )

    def add_notes_batch(
        self,
        notes: list[dict[str, Any]],
    ) -> list[int | None]:
        """
        Adiciona m√∫ltiplas notas de uma vez.

        Args:
            notes: Lista de notas no formato AnkiConnect

        Returns:
            Lista de IDs das notas criadas (None para falhas)
        """
        return self._invoke("addNotes", notes=notes)

    def sync(self) -> None:
        """Sincroniza o Anki com AnkiWeb."""
        self._invoke("sync")
        logger.info("Sincroniza√ß√£o com AnkiWeb conclu√≠da")

    def add_card(
        self,
        card: "AnkiCard",
        deck_name: str,
        allow_duplicate: bool = False,
    ) -> int:
        """
        Adiciona um AnkiCard ao Anki via AnkiConnect.

        Args:
            card: Card a adicionar
            deck_name: Nome do deck
            allow_duplicate: Se True, permite duplicatas

        Returns:
            ID da nota criada
        """
        model = get_model_for_card_type(card.card_type)
        field_values = map_card_to_fields(card)
        field_names = [f["name"] for f in model.fields]

        # Monta dicion√°rio de campos
        fields = dict(zip(field_names, field_values))

        return self.add_note(
            deck_name=deck_name,
            model_name=model.name,
            fields=fields,
            tags=card.tags,
            allow_duplicate=allow_duplicate,
        )

    def add_cards_batch(
        self,
        cards: list["AnkiCard"],
        deck_name: str,
        allow_duplicate: bool = False,
    ) -> list[int | None]:
        """
        Adiciona m√∫ltiplos AnkiCards ao Anki.

        Args:
            cards: Lista de cards a adicionar
            deck_name: Nome do deck
            allow_duplicate: Se True, permite duplicatas

        Returns:
            Lista de IDs das notas criadas
        """
        notes = []

        for card in cards:
            model = get_model_for_card_type(card.card_type)
            field_values = map_card_to_fields(card)
            field_names = [f["name"] for f in model.fields]
            fields = dict(zip(field_names, field_values))

            notes.append(
                {
                    "deckName": deck_name,
                    "modelName": model.name,
                    "fields": fields,
                    "tags": card.tags,
                    "options": {"allowDuplicate": allow_duplicate},
                }
            )

        result = self.add_notes_batch(notes)
        logger.info(
            f"Adicionados {sum(1 for r in result if r is not None)} cards via AnkiConnect"
        )
        return result
</file>

<file path="src/legal_anki/config.py">
"""Configura√ß√µes e constantes do LegalAnki."""

import random
from enum import StrEnum
from pathlib import Path

from dotenv import load_dotenv
from pydantic import Field
from pydantic_settings import BaseSettings

# Carrega .env do diret√≥rio raiz do projeto
_project_root = Path(__file__).parent.parent.parent
load_dotenv(_project_root / ".env")


def _generate_anki_id() -> int:
    """Gera um ID √∫nico v√°lido para modelos/decks Anki."""
    return random.randrange(1 << 30, 1 << 31)


class Settings(BaseSettings):
    """Configura√ß√µes carregadas de vari√°veis de ambiente."""

    # OpenAI
    openai_api_key: str = Field(default="", alias="OPENAI_API_KEY")
    openai_model: str = Field(default="gpt-4o-2024-08-06", alias="OPENAI_MODEL")

    # Anki IDs
    anki_deck_id: int = Field(default_factory=_generate_anki_id, alias="ANKI_DECK_ID")
    anki_model_basic_id: int = Field(
        default_factory=_generate_anki_id, alias="ANKI_MODEL_BASIC_ID"
    )
    anki_model_cloze_id: int = Field(
        default_factory=_generate_anki_id, alias="ANKI_MODEL_CLOZE_ID"
    )
    anki_model_questao_id: int = Field(
        default_factory=_generate_anki_id, alias="ANKI_MODEL_QUESTAO_ID"
    )
    anki_model_jurisprudencia_id: int = Field(
        default_factory=_generate_anki_id, alias="ANKI_MODEL_JURISPRUDENCIA_ID"
    )

    # AnkiConnect
    anki_connect_url: str = Field(
        default="http://localhost:8765", alias="ANKI_CONNECT_URL"
    )

    # Versioning
    skill_version: str = Field(default="1.0.0", alias="SKILL_VERSION")

    model_config = {"env_file": ".env", "env_file_encoding": "utf-8", "extra": "ignore"}


# Inst√¢ncia global de configura√ß√µes
settings = Settings()


class CardType(StrEnum):
    """Tipos de card suportados."""

    BASIC = "basic"
    BASIC_REVERSED = "basic_reversed"
    CLOZE = "cloze"
    QUESTAO = "questao"
    JURISPRUDENCIA = "jurisprudencia"


class Difficulty(StrEnum):
    """N√≠veis de dificuldade."""

    FACIL = "facil"
    MEDIO = "medio"
    DIFICIL = "dificil"
</file>

<file path="src/legal_anki/exporters.py">
"""Exportadores para m√∫ltiplos formatos (CSV, TSV, JSON, APKG)."""

from __future__ import annotations

import base64
import csv
import json
import logging
from datetime import datetime
from io import BytesIO, StringIO
from pathlib import Path
from typing import TYPE_CHECKING

import genanki

from .config import settings
from .models import get_model_for_card_type
from .serializers import map_card_to_fields

if TYPE_CHECKING:
    from .models import AnkiCard

logger = logging.getLogger(__name__)


class ExportError(Exception):
    """Erro durante exporta√ß√£o."""

    pass


# =============================================================================
# CSV Export (DEFAULT)
# =============================================================================


def _sanitize_csv_text(text: str | None) -> str:
    """Remove quebras de linha e caracteres problem√°ticos para CSV."""
    if not text:
        return ""
    return text.replace("\n", " ").replace("\r", "").replace("\t", " ").strip()


def export_to_csv(
    cards: list["AnkiCard"],
    output_path: Path | str | None = None,
    include_header: bool = True,
) -> str | Path:
    """
    Exporta cards para CSV (formato default V1).

    Usa ponto-e-v√≠rgula como separador para compatibilidade com Excel BR.
    Sanitiza quebras de linha para evitar corrup√ß√£o do CSV.

    Args:
        cards: Lista n√£o-vazia de cards a exportar
        output_path: Caminho do arquivo de sa√≠da. Se None, retorna string.
        include_header: Se True, inclui cabe√ßalho

    Returns:
        Path do arquivo criado ou string CSV

    Raises:
        ExportError: Se a lista de cards estiver vazia
    """
    if not cards:
        raise ExportError("Lista de cards vazia para exporta√ß√£o CSV")

    output = StringIO()
    writer = csv.writer(output, delimiter=";", quoting=csv.QUOTE_ALL)

    if include_header:
        writer.writerow(["front", "back", "tags", "type", "extra"])

    for card in cards:
        tags_str = _sanitize_csv_text(" ".join(card.tags))
        extra_str = (
            _sanitize_csv_text(json.dumps(card.extra, ensure_ascii=False))
            if card.extra
            else ""
        )
        writer.writerow(
            [
                _sanitize_csv_text(card.front),
                _sanitize_csv_text(card.back),
                tags_str,
                card.card_type,
                extra_str,
            ]
        )

    csv_content = output.getvalue()

    if output_path is None:
        logger.info(f"Exportados {len(cards)} cards para CSV (string)")
        return csv_content

    output_path = Path(output_path)
    output_path.write_text(csv_content, encoding="utf-8")
    logger.info(f"Exportados {len(cards)} cards para CSV: {output_path}")
    return output_path


# =============================================================================
# TSV Export
# =============================================================================


def _sanitize_tsv_text(text: str | None) -> str:
    """Remove tabs e quebras de linha para TSV."""
    if not text:
        return ""
    # Remove tabs (separador), newlines e r-returns
    return text.replace("\t", " ").replace("\n", " ").replace("\r", " ").strip()


def export_to_tsv(
    cards: list["AnkiCard"],
    output_path: Path | str | None = None,
) -> str | Path:
    """
    Exporta cards para TSV (Tab-Separated Values).

    Formato simples compat√≠vel com importa√ß√£o direta no Anki.

    Args:
        cards: Lista de cards a exportar
        output_path: Caminho do arquivo de sa√≠da. Se None, retorna string.

    Returns:
        Path do arquivo criado ou string TSV
    """
    lines = []

    for card in cards:
        tags_str = _sanitize_tsv_text(" ".join(card.tags))
        # TSV simples: front\tback\ttags
        line = f"{_sanitize_tsv_text(card.front)}\t{_sanitize_tsv_text(card.back)}\t{tags_str}"
        lines.append(line)

    tsv_content = "\n".join(lines)

    if output_path is None:
        return tsv_content

    output_path = Path(output_path)
    output_path.write_text(tsv_content, encoding="utf-8")
    logger.info(f"Exportado {len(cards)} cards para TSV: {output_path}")
    return output_path


# =============================================================================
# JSON Export
# =============================================================================


def export_to_json(
    cards: list["AnkiCard"],
    output_path: Path | str | None = None,
    include_metadata: bool = True,
) -> str | Path:
    """
    Exporta cards para JSON com metadata opcional.

    Args:
        cards: Lista de cards a exportar
        output_path: Caminho do arquivo de sa√≠da. Se None, retorna string JSON.
        include_metadata: Se True, inclui metadata (vers√£o, modelo, timestamp)

    Returns:
        Path do arquivo criado ou string JSON
    """
    data: dict = {}

    if include_metadata:
        data["metadata"] = {
            "skill_version": settings.skill_version,
            "model": settings.openai_model,
            "generated_at": datetime.now().isoformat(),
            "total_cards": len(cards),
        }

    data["cards"] = [card.model_dump() for card in cards]

    json_content = json.dumps(data, ensure_ascii=False, indent=2)

    if output_path is None:
        return json_content

    output_path = Path(output_path)
    output_path.write_text(json_content, encoding="utf-8")
    logger.info(f"Exportado {len(cards)} cards para JSON: {output_path}")
    return output_path


# =============================================================================
# APKG Export
# =============================================================================


def export_to_apkg(
    cards: list["AnkiCard"],
    deck_name: str,
    output_path: Path | str,
) -> Path:
    """
    Exporta cards para arquivo .apkg (Anki Package).

    Args:
        cards: Lista de cards a exportar
        deck_name: Nome do deck no Anki
        output_path: Caminho do arquivo .apkg

    Returns:
        Path do arquivo criado
    """
    output_path = Path(output_path)

    deck = genanki.Deck(
        deck_id=settings.anki_deck_id,
        name=deck_name,
    )

    # Cache de modelos para evitar recria√ß√£o
    models_cache: dict[str, genanki.Model] = {}

    for card in cards:
        # Obt√©m ou cria modelo
        if card.card_type not in models_cache:
            models_cache[card.card_type] = get_model_for_card_type(card.card_type)

        model = models_cache[card.card_type]
        fields = map_card_to_fields(card)

        note = genanki.Note(
            model=model,
            fields=fields,
            tags=card.tags,
        )
        deck.add_note(note)

    package = genanki.Package(deck)
    package.write_to_file(str(output_path))

    logger.info(f"Exportado {len(cards)} cards para APKG: {output_path}")
    return output_path


def export_to_apkg_base64(
    cards: list["AnkiCard"],
    deck_name: str,
) -> str:
    """
    Exporta cards para APKG em formato base64 usando BytesIO (sem tempfile).

    √ötil para APIs e bots que precisam transmitir o arquivo.

    Args:
        cards: Lista de cards a exportar
        deck_name: Nome do deck no Anki

    Returns:
        String base64 do arquivo .apkg
    """
    deck = genanki.Deck(
        deck_id=settings.anki_deck_id,
        name=deck_name,
    )

    # Cache de modelos
    models_cache: dict[str, genanki.Model] = {}

    for card in cards:
        if card.card_type not in models_cache:
            models_cache[card.card_type] = get_model_for_card_type(card.card_type)

        model = models_cache[card.card_type]
        fields = map_card_to_fields(card)

        note = genanki.Note(
            model=model,
            fields=fields,
            tags=card.tags,
        )
        deck.add_note(note)

    package = genanki.Package(deck)

    # Usa BytesIO ao inv√©s de tempfile
    buffer = BytesIO()
    package.write_to_file(buffer)
    buffer.seek(0)

    return base64.b64encode(buffer.read()).decode("utf-8")


# =============================================================================
# Unified Export Function
# =============================================================================


def export_cards(
    cards: list["AnkiCard"],
    output_path: Path | str,
    format: str = "csv",
    deck_name: str = "LegalAnki",
    **kwargs,
) -> Path | str:
    """
    Fun√ß√£o unificada de exporta√ß√£o.

    Args:
        cards: Lista de cards a exportar
        output_path: Caminho do arquivo de sa√≠da
        format: Formato de exporta√ß√£o ("csv", "tsv", "json", "apkg")
        deck_name: Nome do deck (apenas para APKG)
        **kwargs: Argumentos adicionais para o exportador espec√≠fico

    Returns:
        Path do arquivo criado
    """
    format = format.lower()

    if format == "csv":
        return export_to_csv(cards, output_path, **kwargs)
    elif format == "tsv":
        return export_to_tsv(cards, output_path)
    elif format == "json":
        return export_to_json(cards, output_path, **kwargs)
    elif format == "apkg":
        return export_to_apkg(cards, deck_name, output_path)
    else:
        raise ExportError(
            f"Formato n√£o suportado: {format}. Use csv, tsv, json ou apkg."
        )
</file>

<file path="src/legal_anki/generator.py">
"""Gerador de cards Anki via LLM usando OpenAI Structured Outputs."""

from __future__ import annotations

import logging
from typing import TYPE_CHECKING

from .config import settings
from .models import AnkiCard, CardResponse
from .prompts.system import build_system_prompt
from .utils import normalize_tags

if TYPE_CHECKING:
    from .llm.protocol import LLMClient

logger = logging.getLogger(__name__)


class CardGenerationError(Exception):
    """Erro na gera√ß√£o de cards."""

    pass


def generate_cards(
    text: str,
    topic: str,
    difficulty: str = "medio",
    include_legal_basis: bool = True,
    card_type: str = "auto",
    max_cards: int = 10,
    llm_client: "LLMClient | None" = None,
) -> list[AnkiCard]:
    """
    Gera cards Anki a partir de um texto jur√≠dico.

    Args:
        text: Texto fonte (artigo, s√∫mula, quest√£o, etc.)
        topic: T√≥pico principal (ex: "controle_concentrado", "direitos_fundamentais")
        difficulty: N√≠vel de dificuldade ("facil", "medio", "dificil")
        include_legal_basis: Se True, instrui o LLM a sempre incluir fundamento legal
        card_type: Tipo de card a gerar ("auto" para deixar o LLM decidir)
        max_cards: N√∫mero m√°ximo de cards a gerar (1-100)
        llm_client: Cliente LLM opcional. Se None, usa OpenAI padr√£o com retry.

    Returns:
        Lista de AnkiCard gerados

    Raises:
        ValueError: Se os par√¢metros de entrada forem inv√°lidos
        CardGenerationError: Se houver erro na gera√ß√£o
    """
    # Valida√ß√£o de inputs
    if not text or not text.strip():
        raise ValueError("Par√¢metro 'text' n√£o pode ser vazio")
    if not topic or not topic.strip():
        raise ValueError("Par√¢metro 'topic' n√£o pode ser vazio")
    if max_cards < 1 or max_cards > 100:
        raise ValueError("Par√¢metro 'max_cards' deve estar entre 1 e 100")

    text = text.strip()
    topic = topic.strip()

    if llm_client is None:
        if not settings.openai_api_key:
            raise CardGenerationError(
                "OPENAI_API_KEY n√£o configurada. Configure em .env ou vari√°vel de ambiente."
            )

        from .llm.openai_client import OpenAILLMClient

        llm_client = OpenAILLMClient(
            api_key=settings.openai_api_key,
            model=settings.openai_model,
        )

    system_prompt = build_system_prompt(
        include_legal_basis=include_legal_basis,
        difficulty=difficulty,
    )

    user_message = _build_user_message(text, topic, card_type, max_cards)

    logger.info(f"Gerando cards para t√≥pico '{topic}'")

    try:
        result = llm_client.generate_structured(
            system_prompt=system_prompt,
            user_message=user_message,
            response_model=CardResponse,
        )

        if not result or not result.cards:
            raise CardGenerationError("LLM n√£o retornou nenhum card")

        # P√≥s-processamento
        cards = _postprocess_cards(result.cards, topic, difficulty)

        logger.info(f"Gerados {len(cards)} cards com sucesso")
        return cards

    except CardGenerationError:
        raise
    except Exception as e:
        logger.error(f"Erro na gera√ß√£o de cards: {e}")
        raise CardGenerationError(f"Erro ao gerar cards: {e}") from e


def _build_user_message(text: str, topic: str, card_type: str, max_cards: int) -> str:
    """Constr√≥i a mensagem do usu√°rio para o LLM."""
    type_instruction = ""
    if card_type != "auto":
        type_instruction = f"\n\nGere apenas cards do tipo '{card_type}'."

    return f"""Gere at√© {max_cards} flashcards Anki sobre o seguinte conte√∫do:

**T√≥pico**: {topic}

---
{text}
---

{type_instruction}

Retorne os cards em formato JSON conforme especificado."""


def _postprocess_cards(
    cards: list[AnkiCard], topic: str, difficulty: str
) -> list[AnkiCard]:
    """
    P√≥s-processa os cards gerados.

    - Normaliza tags
    - Adiciona tag de t√≥pico e dificuldade
    - Limpa espa√ßos extras
    """
    processed = []

    for card in cards:
        # Normaliza tags existentes
        tags = normalize_tags(card.tags)

        # Adiciona tag de t√≥pico se n√£o existir
        topic_tag = normalize_tags([topic])[0] if topic else None
        if topic_tag and topic_tag not in tags:
            tags.insert(0, topic_tag)

        # Adiciona tag de dificuldade
        diff_tag = f"dificuldade_{difficulty}"
        if diff_tag not in tags:
            tags.append(diff_tag)

        # Cria novo card com tags normalizadas
        processed_card = AnkiCard(
            front=card.front.strip(),
            back=card.back.strip(),
            card_type=card.card_type,
            tags=tags,
            extra=card.extra,
        )
        processed.append(processed_card)

    return processed
</file>

<file path="src/legal_anki/models.py">
"""Modelos Anki especializados para Direito Constitucional."""

from typing import Literal

import genanki
from pydantic import BaseModel, Field, field_validator

from .config import CardType, settings

# =============================================================================
# Modelos Pydantic para Cards
# =============================================================================


class AnkiCard(BaseModel):
    """Modelo de um card Anki gerado."""

    front: str = Field(
        min_length=1, description="Texto da frente do card (pergunta ou cloze)"
    )
    back: str = Field(min_length=1, description="Texto do verso do card (resposta)")
    card_type: Literal[
        "basic", "basic_reversed", "cloze", "questao", "jurisprudencia"
    ] = Field(description="Tipo do card")
    tags: list[str] = Field(
        default_factory=list, description="Lista de tags para o card"
    )
    extra: dict | None = Field(
        default=None,
        description="Campos adicionais dependendo do tipo (banca, ano, tribunal, fundamento, etc.)",
    )

    @field_validator("front", "back", mode="before")
    @classmethod
    def strip_and_validate(cls, v: str) -> str:
        """Remove espa√ßos extras e valida que o campo n√£o est√° vazio."""
        if not isinstance(v, str):
            raise ValueError("Campo deve ser uma string")
        stripped = v.strip()
        if not stripped:
            raise ValueError("Campo n√£o pode ser vazio")
        return stripped


class CardResponse(BaseModel):
    """Resposta estruturada do LLM com lista de cards."""

    cards: list[AnkiCard] = Field(description="Lista de cards gerados")


# =============================================================================
# Modelos Genanki (templates Anki)
# =============================================================================


# CSS compartilhado para todos os modelos
CARD_CSS = """
.card {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    font-size: 18px;
    text-align: left;
    color: #333;
    background-color: #fafafa;
    padding: 20px;
    line-height: 1.6;
}

.question {
    font-size: 20px;
    font-weight: 500;
    margin-bottom: 15px;
}

.answer {
    margin-top: 15px;
}

.metadata {
    font-size: 13px;
    color: #666;
    margin-top: 10px;
    padding: 8px;
    background-color: #f0f0f0;
    border-radius: 4px;
}

.fundamento {
    margin-top: 15px;
    padding: 10px;
    background-color: #e8f4f8;
    border-left: 4px solid #0077b6;
    font-size: 14px;
    color: #333;
}

.cloze {
    font-weight: bold;
    color: #0077b6;
}

.extra {
    margin-top: 15px;
    font-size: 14px;
    color: #555;
    border-top: 1px solid #ddd;
    padding-top: 10px;
}

hr#answer {
    border: none;
    border-top: 2px solid #0077b6;
    margin: 20px 0;
}
"""


def create_basic_model() -> genanki.Model:
    """Cria modelo Basic (Pergunta/Resposta)."""
    return genanki.Model(
        model_id=settings.anki_model_basic_id,
        name="LegalAnki Basic",
        fields=[
            {"name": "Front"},
            {"name": "Back"},
        ],
        templates=[
            {
                "name": "Card 1",
                "qfmt": '<div class="question">{{Front}}</div>',
                "afmt": """
                    {{FrontSide}}
                    <hr id="answer">
                    <div class="answer">{{Back}}</div>
                """,
            }
        ],
        css=CARD_CSS,
    )


def create_cloze_model() -> genanki.Model:
    """Cria modelo Cloze para lacunas."""
    return genanki.Model(
        model_id=settings.anki_model_cloze_id,
        name="LegalAnki Cloze",
        model_type=genanki.Model.CLOZE,
        fields=[
            {"name": "Text"},
            {"name": "Extra"},
        ],
        templates=[
            {
                "name": "Cloze",
                "qfmt": "{{cloze:Text}}",
                "afmt": """
                    {{cloze:Text}}
                    {{#Extra}}
                    <div class="extra">{{Extra}}</div>
                    {{/Extra}}
                """,
            }
        ],
        css=CARD_CSS,
    )


def create_questao_model() -> genanki.Model:
    """Cria modelo para quest√µes de concurso."""
    return genanki.Model(
        model_id=settings.anki_model_questao_id,
        name="LegalAnki Questao",
        fields=[
            {"name": "Front"},
            {"name": "Back"},
            {"name": "Banca"},
            {"name": "Ano"},
            {"name": "Cargo"},
            {"name": "Fundamento"},
        ],
        templates=[
            {
                "name": "Quest√£o Concurso",
                "qfmt": """
                    <div class="question">{{Front}}</div>
                    <div class="metadata">
                        {{#Banca}}{{Banca}}{{/Banca}}
                        {{#Ano}} - {{Ano}}{{/Ano}}
                        {{#Cargo}} - {{Cargo}}{{/Cargo}}
                    </div>
                """,
                "afmt": """
                    {{FrontSide}}
                    <hr id="answer">
                    <div class="answer">{{Back}}</div>
                    {{#Fundamento}}
                    <div class="fundamento">
                        <strong>üìö Fundamento:</strong><br>
                        {{Fundamento}}
                    </div>
                    {{/Fundamento}}
                """,
            }
        ],
        css=CARD_CSS,
    )


def create_jurisprudencia_model() -> genanki.Model:
    """Cria modelo para s√∫mulas e julgados."""
    return genanki.Model(
        model_id=settings.anki_model_jurisprudencia_id,
        name="LegalAnki Jurisprudencia",
        fields=[
            {"name": "Front"},
            {"name": "Back"},
            {"name": "Tribunal"},
            {"name": "DataJulgamento"},
            {"name": "Tema"},
            {"name": "FundamentoLegal"},
        ],
        templates=[
            {
                "name": "Jurisprud√™ncia",
                "qfmt": """
                    <div class="question">{{Front}}</div>
                    <div class="metadata">
                        {{#Tribunal}}üèõÔ∏è {{Tribunal}}{{/Tribunal}}
                        {{#Tema}} | üìå {{Tema}}{{/Tema}}
                    </div>
                """,
                "afmt": """
                    {{FrontSide}}
                    <hr id="answer">
                    <div class="answer">{{Back}}</div>
                    {{#DataJulgamento}}
                    <div class="metadata">üìÖ Julgado em: {{DataJulgamento}}</div>
                    {{/DataJulgamento}}
                    {{#FundamentoLegal}}
                    <div class="fundamento">
                        <strong>üìú Base Legal:</strong><br>
                        {{FundamentoLegal}}
                    </div>
                    {{/FundamentoLegal}}
                """,
            }
        ],
        css=CARD_CSS,
    )


# Mapeamento de tipo para modelo - usa CardType Enum
_MODEL_FACTORY = {
    CardType.BASIC: create_basic_model,
    CardType.BASIC_REVERSED: create_basic_model,  # Usa mesmo modelo, gera 2 notes
    CardType.CLOZE: create_cloze_model,
    CardType.QUESTAO: create_questao_model,
    CardType.JURISPRUDENCIA: create_jurisprudencia_model,
}


def get_model_for_card_type(card_type: str) -> genanki.Model:
    """Retorna o modelo Anki apropriado para o tipo de card."""
    factory = _MODEL_FACTORY.get(card_type)
    if not factory:
        raise ValueError(f"Tipo de card desconhecido: {card_type}")
    return factory()


def get_field_names_for_card_type(card_type: str) -> list[str]:
    """Retorna os nomes dos campos para um tipo de card."""
    model = get_model_for_card_type(card_type)
    return [f["name"] for f in model.fields]
</file>

<file path="src/legal_anki/serializers.py">
"""Serializadores para convers√£o de cards Anki para diferentes formatos."""

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from .models import AnkiCard


def map_card_to_fields(card: "AnkiCard") -> list[str]:
    """
    Mapeia um AnkiCard para os campos do modelo Anki correspondente.

    Args:
        card: Card a ser mapeado

    Returns:
        Lista de valores de campos na ordem correta para o modelo
    """
    extra = card.extra or {}

    if card.card_type == "cloze":
        return [
            card.front,  # Text (com marca√ß√µes cloze)
            extra.get("fundamento", ""),  # Extra
        ]

    if card.card_type == "questao":
        return [
            card.front,
            card.back,
            extra.get("banca", ""),
            extra.get("ano", ""),
            extra.get("cargo", ""),
            extra.get("fundamento", ""),
        ]

    if card.card_type == "jurisprudencia":
        return [
            card.front,
            card.back,
            extra.get("tribunal", ""),
            extra.get("data_julgamento", ""),
            extra.get("tema", ""),
            extra.get("fundamento_legal", ""),
        ]

    # basic e basic_reversed
    return [card.front, card.back]
</file>

<file path="src/legal_anki/utils.py">
"""Utilit√°rios para normaliza√ß√£o e fun√ß√µes auxiliares."""

import random
import re
import unicodedata


def slugify_tag(tag: str) -> str:
    """
    Normaliza tag para formato Anki-friendly.

    Remove acentos, substitui espa√ßos por underscores e remove caracteres especiais.

    Args:
        tag: Tag original a ser normalizada

    Returns:
        Tag normalizada em lowercase sem acentos ou espa√ßos
    """
    if not tag:
        return ""

    # Remove acentos
    tag = unicodedata.normalize("NFKD", tag)
    tag = tag.encode("ascii", "ignore").decode("ascii")

    # Substitui espa√ßos por underscores
    tag = re.sub(r"\s+", "_", tag.strip())

    # Remove caracteres especiais (mant√©m letras, n√∫meros, underscore e h√≠fen)
    tag = re.sub(r"[^\w\-]", "", tag)

    return tag.lower()


def normalize_tags(tags: list[str]) -> list[str]:
    """
    Normaliza lista de tags.

    Args:
        tags: Lista de tags originais

    Returns:
        Lista de tags normalizadas, sem duplicatas e sem vazios
    """
    normalized = [slugify_tag(t) for t in tags if t]
    # Remove duplicatas mantendo ordem
    seen = set()
    unique = []
    for tag in normalized:
        if tag and tag not in seen:
            seen.add(tag)
            unique.append(tag)
    return unique


def generate_unique_id() -> int:
    """
    Gera ID √∫nico v√°lido para modelos/decks Anki.

    Returns:
        Inteiro no range v√°lido para IDs Anki
    """
    return random.randrange(1 << 30, 1 << 31)


def escape_html(text: str) -> str:
    """
    Escapa caracteres HTML especiais.

    Args:
        text: Texto a ser escapado

    Returns:
        Texto com caracteres HTML escapados
    """
    if not text:
        return ""
    replacements = [
        ("&", "&amp;"),
        ("<", "&lt;"),
        (">", "&gt;"),
        ('"', "&quot;"),
        ("'", "&#x27;"),
    ]
    for old, new in replacements:
        text = text.replace(old, new)
    return text


def truncate_text(text: str, max_length: int = 100, suffix: str = "...") -> str:
    """
    Trunca texto para um comprimento m√°ximo.

    Args:
        text: Texto a ser truncado
        max_length: Comprimento m√°ximo
        suffix: Sufixo a adicionar se truncado

    Returns:
        Texto truncado com sufixo se necess√°rio
    """
    if not text or len(text) <= max_length:
        return text or ""
    return text[: max_length - len(suffix)].rstrip() + suffix
</file>

<file path="src/legal_anki/validators.py">
"""Validadores para cards gerados pelo LLM."""

from __future__ import annotations

from typing import TYPE_CHECKING

from .config import CardType

if TYPE_CHECKING:
    from .models import AnkiCard


class CardValidationError(Exception):
    """Erro de valida√ß√£o de card."""

    def __init__(self, errors: list[str], card: "AnkiCard | None" = None):
        self.errors = errors
        self.card = card
        super().__init__("; ".join(errors))


def validate_card(
    card: "AnkiCard",
    require_legal_basis: bool = True,
    min_front_length: int = 10,
    min_back_length: int = 5,
) -> bool:
    """
    Valida um card gerado pelo LLM.

    Args:
        card: Card a ser validado
        require_legal_basis: Se True, exige fundamento legal
        min_front_length: Comprimento m√≠nimo do front
        min_back_length: Comprimento m√≠nimo do back

    Returns:
        True se v√°lido

    Raises:
        CardValidationError: Se o card for inv√°lido
    """
    errors = []

    # Valida√ß√£o de campos obrigat√≥rios b√°sicos
    if not card.front or len(card.front.strip()) < min_front_length:
        errors.append(f"Front muito curto (m√≠nimo {min_front_length} caracteres)")

    if not card.back or len(card.back.strip()) < min_back_length:
        errors.append(f"Back muito curto (m√≠nimo {min_back_length} caracteres)")

    if not card.tags:
        errors.append("Card sem tags")

    # Valida√ß√£o do tipo de card usando Enum
    valid_types = [t.value for t in CardType]
    if card.card_type not in valid_types:
        errors.append(f"Tipo de card inv√°lido: {card.card_type}")

    # Valida√ß√£o espec√≠fica por tipo
    if card.card_type == CardType.CLOZE:
        if "{{c1::" not in card.front and "{{c2::" not in card.front:
            errors.append("Card cloze sem marca√ß√£o de lacuna ({{c1::...}})")

    if card.card_type == CardType.QUESTAO:
        if not card.extra or not card.extra.get("banca"):
            errors.append("Quest√£o sem banca definida")

    if card.card_type == CardType.JURISPRUDENCIA:
        if not card.extra or not card.extra.get("tribunal"):
            errors.append("Jurisprud√™ncia sem tribunal definido")

    # Valida√ß√£o de fundamento legal
    if require_legal_basis:
        has_fundamento = _check_legal_basis(card)
        if not has_fundamento:
            errors.append("Card sem fundamento legal (art., s√∫mula, ADI, etc.)")

    if errors:
        raise CardValidationError(errors, card)

    return True


def _check_legal_basis(card: "AnkiCard") -> bool:
    """
    Verifica se o card cont√©m fundamento legal.

    Procura em extra.fundamento, extra.fundamento_legal ou no pr√≥prio back.
    """
    # Verifica em extra
    if card.extra:
        fundamento = card.extra.get("fundamento") or card.extra.get("fundamento_legal")
        if fundamento and len(str(fundamento).strip()) > 3:
            return True

    # Verifica keywords no back
    keywords = [
        "art.",
        "artigo",
        "s√∫mula",
        "sumula",
        "sv ",
        "adi",
        "adc",
        "adpf",
        "¬ß",
        "inciso",
        "al√≠nea",
        "cf/88",
        "cf/1988",
        "constitui√ß√£o federal",
        "re ",
        "resp",
        "hc ",
        "ms ",
    ]

    back_lower = card.back.lower() if card.back else ""
    return any(kw in back_lower for kw in keywords)


def validate_cards_batch(
    cards: list["AnkiCard"],
    require_legal_basis: bool = True,
    skip_invalid: bool = False,
) -> tuple[list["AnkiCard"], list[CardValidationError]]:
    """
    Valida uma lista de cards.

    Args:
        cards: Lista de cards a validar
        require_legal_basis: Se True, exige fundamento legal
        skip_invalid: Se True, retorna cards v√°lidos e lista de erros;
                     Se False, levanta exce√ß√£o no primeiro erro

    Returns:
        Tupla (cards_v√°lidos, erros) se skip_invalid=True

    Raises:
        CardValidationError: Se skip_invalid=False e algum card for inv√°lido
    """
    valid_cards = []
    errors = []

    for card in cards:
        try:
            validate_card(card, require_legal_basis=require_legal_basis)
            valid_cards.append(card)
        except CardValidationError as e:
            if skip_invalid:
                errors.append(e)
            else:
                raise

    return valid_cards, errors
</file>

<file path="tests/conftest.py">
"""Configura√ß√£o do pytest."""

import sys
from pathlib import Path

import pytest

# Adiciona src ao path
src_path = Path(__file__).parent.parent / "src"
sys.path.insert(0, str(src_path))


@pytest.fixture
def sample_cards():
    """Retorna cards de exemplo para testes."""
    from legal_anki.models import AnkiCard

    return [
        AnkiCard(
            front="Qual √© o fundamento constitucional do direito ao sil√™ncio?",
            back="Art. 5¬∫, LXIII, CF/88 - O preso tem direito de permanecer calado.",
            card_type="basic",
            tags=["direitos_fundamentais", "garantias_processuais"],
            extra={"fundamento": "Art. 5¬∫, LXIII, CF/88"},
        ),
        AnkiCard(
            front="A S√∫mula Vinculante {{c1::11}} trata do uso de {{c2::algemas}}.",
            back="SV 11 - Uso de algemas",
            card_type="cloze",
            tags=["sumulas_vinculantes", "stf"],
            extra={"fundamento": "Art. 5¬∫, III, X e XLIX, CF/88"},
        ),
        AnkiCard(
            front="(CESPE/2023) O direito ao sil√™ncio √© absoluto e n√£o admite exce√ß√µes.",
            back="ERRADO. O direito ao sil√™ncio n√£o √© absoluto. Existem situa√ß√µes em que o acusado deve se identificar.",
            card_type="questao",
            tags=["direitos_fundamentais", "cespe"],
            extra={
                "banca": "CESPE",
                "ano": "2023",
                "cargo": "Juiz Federal",
                "fundamento": "Art. 5¬∫, LXIII, CF/88",
            },
        ),
        AnkiCard(
            front="Qual o entendimento do STF sobre uso de algemas?",
            back="S√≥ √© l√≠cito o uso de algemas em casos de resist√™ncia, fundado receio de fuga ou perigo.",
            card_type="jurisprudencia",
            tags=["stf", "sumulas_vinculantes"],
            extra={
                "tribunal": "STF",
                "tema": "Uso de algemas",
                "fundamento_legal": "S√∫mula Vinculante 11",
            },
        ),
    ]


@pytest.fixture
def sample_card_basic():
    """Retorna um card b√°sico para testes."""
    from legal_anki.models import AnkiCard

    return AnkiCard(
        front="Qual √© o fundamento constitucional do direito ao sil√™ncio?",
        back="Art. 5¬∫, LXIII, CF/88 - O preso tem direito de permanecer calado.",
        card_type="basic",
        tags=["direitos_fundamentais"],
        extra={"fundamento": "Art. 5¬∫, LXIII, CF/88"},
    )


@pytest.fixture
def sample_card_invalid():
    """Retorna um card inv√°lido para testes de valida√ß√£o de regras de neg√≥cio.

    O card √© v√°lido do ponto de vista Pydantic (campos preenchidos), mas
    inv√°lido para os validadores de neg√≥cio (front curto, sem fundamento legal).
    """
    from legal_anki.models import AnkiCard

    return AnkiCard(
        front="X",  # Muito curto para regras de neg√≥cio
        back="Y",  # Muito curto para regras de neg√≥cio
        card_type="basic",
        tags=[],  # Sem tags
        extra=None,  # Sem fundamento legal
    )
</file>

<file path="tests/test_exporters.py">
"""Testes para o m√≥dulo de exporta√ß√£o."""

import json
import tempfile
from pathlib import Path

import pytest


class TestExportToCSV:
    """Testes para exporta√ß√£o CSV."""

    def test_export_csv_to_string(self, sample_cards):
        """Exporta√ß√£o CSV sem arquivo retorna string."""
        from legal_anki.exporters import export_to_csv

        result = export_to_csv(sample_cards, output_path=None)

        assert isinstance(result, str)
        assert "front" in result  # Header
        assert ";" in result  # Separador

    def test_export_csv_to_file(self, sample_cards):
        """Exporta√ß√£o CSV cria arquivo v√°lido."""
        from legal_anki.exporters import export_to_csv

        with tempfile.NamedTemporaryFile(suffix=".csv", delete=False) as tmp:
            result = export_to_csv(sample_cards, Path(tmp.name))

            assert Path(result).exists()
            content = Path(result).read_text(encoding="utf-8")
            assert len(content) > 0

            # Cleanup
            Path(tmp.name).unlink()

    def test_export_csv_without_header(self, sample_cards):
        """Exporta√ß√£o CSV sem header."""
        from legal_anki.exporters import export_to_csv

        result = export_to_csv(sample_cards, output_path=None, include_header=False)

        assert "front" not in result.split("\n")[0]

    def test_export_csv_empty_list_raises_error(self):
        """Exporta√ß√£o com lista vazia deve levantar ExportError."""
        from legal_anki.exporters import ExportError, export_to_csv

        with pytest.raises(ExportError, match="vazia"):
            export_to_csv([])

    def test_export_csv_sanitizes_newlines(self):
        """Newlines no conte√∫do s√£o substitu√≠dos por espa√ßo."""
        from legal_anki.exporters import export_to_csv
        from legal_anki.models import AnkiCard

        card = AnkiCard(
            front="Pergunta\ncom quebra",
            back="Resposta\nmulti-linha",
            card_type="basic",
            tags=["test"],
            extra=None,
        )
        result = export_to_csv([card], include_header=False)

        # A linha de dados n√£o deve conter \n no conte√∫do
        lines = result.strip().split("\n")
        assert len(lines) == 1  # Apenas uma linha de dados
        assert "Pergunta com quebra" in result
        assert "Resposta multi-linha" in result

    def test_export_csv_handles_legal_characters(self):
        """Caracteres jur√≠dicos (¬ß, ¬∫, ¬™) s√£o preservados corretamente."""
        from legal_anki.exporters import export_to_csv
        from legal_anki.models import AnkiCard

        card = AnkiCard(
            front="Art. 5¬∫, ¬ß 1¬∫ da CF/88",
            back="Os direitos e garantias fundamentais t√™m aplica√ß√£o imediata.",
            card_type="basic",
            tags=["cf88", "direitos_fundamentais"],
            extra={"fundamento": "Art. 5¬∫, ¬ß 1¬∫, CF/88"},
        )
        result = export_to_csv([card])

        assert "¬ß" in result
        assert "¬∫" in result
        assert "Art. 5¬∫, ¬ß 1¬∫" in result


class TestExportToTSV:
    """Testes para exporta√ß√£o TSV."""

    def test_export_tsv_to_string(self, sample_cards):
        """Exporta√ß√£o TSV sem arquivo retorna string."""
        from legal_anki.exporters import export_to_tsv

        result = export_to_tsv(sample_cards, output_path=None)

        assert isinstance(result, str)
        assert "\t" in result  # Tab separator

    def test_export_tsv_to_file(self, sample_cards):
        """Exporta√ß√£o TSV cria arquivo v√°lido."""
        from legal_anki.exporters import export_to_tsv

        with tempfile.NamedTemporaryFile(suffix=".tsv", delete=False) as tmp:
            result = export_to_tsv(sample_cards, Path(tmp.name))

            assert Path(result).exists()
            content = Path(result).read_text(encoding="utf-8")
            lines = content.strip().split("\n")
            assert len(lines) == len(sample_cards)

            Path(tmp.name).unlink()


class TestExportToJSON:
    """Testes para exporta√ß√£o JSON."""

    def test_export_json_to_string(self, sample_cards):
        """Exporta√ß√£o JSON sem arquivo retorna string v√°lida."""
        from legal_anki.exporters import export_to_json

        result = export_to_json(sample_cards, output_path=None)

        data = json.loads(result)
        assert "cards" in data
        assert len(data["cards"]) == len(sample_cards)

    def test_export_json_with_metadata(self, sample_cards):
        """Exporta√ß√£o JSON inclui metadata."""
        from legal_anki.exporters import export_to_json

        result = export_to_json(sample_cards, output_path=None, include_metadata=True)

        data = json.loads(result)
        assert "metadata" in data
        assert "skill_version" in data["metadata"]
        assert "generated_at" in data["metadata"]

    def test_export_json_without_metadata(self, sample_cards):
        """Exporta√ß√£o JSON sem metadata."""
        from legal_anki.exporters import export_to_json

        result = export_to_json(sample_cards, output_path=None, include_metadata=False)

        data = json.loads(result)
        assert "metadata" not in data or data.get("metadata") is None


class TestExportToAPKG:
    """Testes para exporta√ß√£o APKG."""

    def test_export_apkg_creates_file(self, sample_cards):
        """Exporta√ß√£o APKG cria arquivo v√°lido."""
        from legal_anki.exporters import export_to_apkg

        with tempfile.NamedTemporaryFile(suffix=".apkg", delete=False) as tmp:
            result = export_to_apkg(
                sample_cards,
                deck_name="Test Deck",
                output_path=Path(tmp.name),
            )

            assert Path(result).exists()
            assert Path(result).stat().st_size > 0

            Path(tmp.name).unlink()

    def test_export_apkg_base64(self, sample_cards):
        """Exporta√ß√£o APKG base64 retorna string v√°lida."""
        import base64

        from legal_anki.exporters import export_to_apkg_base64

        result = export_to_apkg_base64(sample_cards, deck_name="Test Deck")

        assert isinstance(result, str)
        # Deve ser base64 v√°lido
        decoded = base64.b64decode(result)
        assert len(decoded) > 0


class TestExportCards:
    """Testes para fun√ß√£o unificada de exporta√ß√£o."""

    def test_export_cards_csv_default(self, sample_cards):
        """Formato default √© CSV."""
        from legal_anki.exporters import export_cards

        with tempfile.NamedTemporaryFile(suffix=".csv", delete=False) as tmp:
            result = export_cards(sample_cards, Path(tmp.name))

            content = Path(result).read_text(encoding="utf-8")
            assert ";" in content

            Path(tmp.name).unlink()

    def test_export_cards_invalid_format(self, sample_cards):
        """Formato inv√°lido levanta exce√ß√£o."""
        from legal_anki.exporters import ExportError, export_cards

        with pytest.raises(ExportError):
            export_cards(sample_cards, "test.xyz", format="xyz")


class TestMapCardToFields:
    """Testes para mapeamento de cards para campos."""

    def test_map_basic_card(self, sample_card_basic):
        """Mapeia card basic corretamente."""
        from legal_anki.exporters import map_card_to_fields

        fields = map_card_to_fields(sample_card_basic)

        assert len(fields) == 2
        assert fields[0] == sample_card_basic.front
        assert fields[1] == sample_card_basic.back

    def test_map_questao_card(self, sample_cards):
        """Mapeia card questao com todos os campos."""
        from legal_anki.exporters import map_card_to_fields

        questao_card = next(c for c in sample_cards if c.card_type == "questao")
        fields = map_card_to_fields(questao_card)

        assert len(fields) == 6  # Front, Back, Banca, Ano, Cargo, Fundamento
        assert fields[2] == "CESPE"  # Banca
        assert fields[3] == "2023"  # Ano

    def test_map_jurisprudencia_card(self, sample_cards):
        """Mapeia card jurisprudencia com todos os campos."""
        from legal_anki.exporters import map_card_to_fields

        juris_card = next(c for c in sample_cards if c.card_type == "jurisprudencia")
        fields = map_card_to_fields(juris_card)

        assert len(fields) == 6  # Front, Back, Tribunal, Data, Tema, Fundamento
        assert fields[2] == "STF"  # Tribunal
</file>

<file path="tests/test_llm_client.py">
"""Testes para o m√≥dulo LLM."""

from unittest.mock import MagicMock, patch

from legal_anki.generator import generate_cards
from legal_anki.models import AnkiCard, CardResponse


class MockLLMClient:
    """Mock de LLMClient para testes."""

    def __init__(self, cards: list[AnkiCard] | None = None):
        self.cards = cards or [
            AnkiCard(
                front="Qual o prazo para propositura de ADI?",
                back="N√£o h√° prazo. A ADI pode ser proposta a qualquer tempo.",
                card_type="basic",
                tags=["controle_concentrado", "adi"],
                extra={"fundamento": "Art. 103 CF/88"},
            ),
        ]
        self.call_count = 0
        self.last_call = None

    def generate_structured(self, system_prompt, user_message, response_model):
        """Implementa o protocolo LLMClient."""
        self.call_count += 1
        self.last_call = {
            "system_prompt": system_prompt,
            "user_message": user_message,
            "response_model": response_model,
        }
        return CardResponse(cards=self.cards)


class TestLLMClientProtocol:
    """Testes para o protocolo LLMClient."""

    def test_mock_client_implements_protocol(self):
        """Mock client implementa a interface."""

        mock = MockLLMClient()

        # Verifica que tem os m√©todos necess√°rios
        assert hasattr(mock, "generate_structured")
        assert callable(mock.generate_structured)


class TestGenerateCardsWithMockClient:
    """Testes de generate_cards com mock client."""

    def test_generate_cards_with_mock_returns_cards(self):
        """Gera√ß√£o com mock retorna cards."""
        mock = MockLLMClient()

        cards = generate_cards(
            text="Texto de teste sobre ADI",
            topic="controle_concentrado",
            llm_client=mock,
        )

        assert len(cards) == 1
        assert cards[0].front == "Qual o prazo para propositura de ADI?"
        assert mock.call_count == 1

    def test_generate_cards_passes_correct_params(self):
        """Par√¢metros corretos s√£o passados ao client."""
        mock = MockLLMClient()

        generate_cards(
            text="Texto sobre direitos fundamentais",
            topic="direitos_fundamentais",
            difficulty="dificil",
            include_legal_basis=True,
            llm_client=mock,
        )

        assert mock.last_call is not None
        assert "direitos_fundamentais" in mock.last_call["user_message"]
        assert mock.last_call["response_model"] == CardResponse

    def test_generate_cards_adds_topic_tag(self):
        """Topic tag √© adicionada aos cards."""
        mock = MockLLMClient(
            cards=[
                AnkiCard(
                    front="Pergunta?",
                    back="Resposta com art. 5¬∫ CF",
                    card_type="basic",
                    tags=["stf"],
                    extra=None,
                ),
            ]
        )

        cards = generate_cards(
            text="Texto",
            topic="direitos_fundamentais",
            llm_client=mock,
        )

        assert "direitos_fundamentais" in cards[0].tags

    def test_generate_cards_adds_difficulty_tag(self):
        """Difficulty tag √© adicionada."""
        mock = MockLLMClient()

        cards = generate_cards(
            text="Texto",
            topic="topic",
            difficulty="dificil",
            llm_client=mock,
        )

        assert "dificuldade_dificil" in cards[0].tags


class TestOpenAILLMClient:
    """Testes para OpenAILLMClient."""

    def test_client_initialization(self):
        """Cliente inicializa corretamente."""
        from legal_anki.llm.openai_client import OpenAILLMClient

        client = OpenAILLMClient(
            api_key="test-key",
            model="gpt-4o-mini",
            max_retries=5,
        )

        assert client.model == "gpt-4o-mini"
        assert client.max_retries == 5

    @patch("legal_anki.llm.openai_client.OpenAI")
    def test_client_calls_openai_parse(self, mock_openai_class):
        """Cliente chama OpenAI.beta.chat.completions.parse."""
        from legal_anki.llm.openai_client import OpenAILLMClient

        # Setup mock
        mock_client = MagicMock()
        mock_response = MagicMock()
        mock_message = MagicMock()
        mock_message.parsed = CardResponse(
            cards=[
                AnkiCard(
                    front="Q?",
                    back="A com art. 1¬∫",
                    card_type="basic",
                    tags=["tag"],
                    extra=None,
                )
            ]
        )
        mock_message.refusal = None
        mock_response.choices = [MagicMock(message=mock_message)]
        mock_client.beta.chat.completions.parse.return_value = mock_response
        mock_openai_class.return_value = mock_client

        # Execute
        client = OpenAILLMClient(api_key="test-key")
        result = client.generate_structured(
            system_prompt="System",
            user_message="User",
            response_model=CardResponse,
        )

        # Verify
        assert len(result.cards) == 1
        mock_client.beta.chat.completions.parse.assert_called_once()
</file>

<file path="tests/test_utils.py">
"""Testes para utilit√°rios."""

from legal_anki.utils import (
    escape_html,
    generate_unique_id,
    normalize_tags,
    slugify_tag,
    truncate_text,
)


class TestSlugifyTag:
    """Testes para slugify_tag."""

    def test_remove_accents(self):
        """Remove acentos corretamente."""
        assert slugify_tag("Constitui√ß√£o") == "constituicao"
        assert slugify_tag("S√∫mula Vinculante") == "sumula_vinculante"
        assert slugify_tag("A√ß√£o Direta") == "acao_direta"

    def test_replace_spaces(self):
        """Substitui espa√ßos por underscores."""
        assert slugify_tag("direitos fundamentais") == "direitos_fundamentais"
        assert slugify_tag("  multiplos   espacos  ") == "multiplos_espacos"

    def test_remove_special_chars(self):
        """Remove caracteres especiais."""
        assert slugify_tag("art. 5¬∫") == "art_5o"  # ¬∫ vira 'o' no NFKD
        assert slugify_tag("CF/88") == "cf88"
        assert slugify_tag("(CESPE)") == "cespe"

    def test_lowercase(self):
        """Converte para lowercase."""
        assert slugify_tag("STF") == "stf"
        assert slugify_tag("CESPE") == "cespe"

    def test_empty_string(self):
        """Retorna vazio para string vazia."""
        assert slugify_tag("") == ""
        assert slugify_tag("   ") == ""

    def test_preserves_hyphen(self):
        """Preserva h√≠fens."""
        assert slugify_tag("controle-concentrado") == "controle-concentrado"


class TestNormalizeTags:
    """Testes para normalize_tags."""

    def test_normalize_list(self):
        """Normaliza lista de tags."""
        tags = ["Direito Constitucional", "STF", "Art. 5¬∫"]
        result = normalize_tags(tags)

        assert "direito_constitucional" in result
        assert "stf" in result
        assert "art_5o" in result  # ¬∫ vira 'o' no NFKD

    def test_remove_duplicates(self):
        """Remove duplicatas mantendo ordem."""
        tags = ["stf", "STF", "stf"]
        result = normalize_tags(tags)

        assert len(result) == 1
        assert result[0] == "stf"

    def test_remove_empty(self):
        """Remove tags vazias."""
        tags = ["stf", "", "  ", "cespe"]
        result = normalize_tags(tags)

        assert len(result) == 2
        assert "" not in result


class TestGenerateUniqueId:
    """Testes para generate_unique_id."""

    def test_returns_valid_range(self):
        """Retorna ID no range v√°lido do Anki."""
        for _ in range(100):
            id = generate_unique_id()
            assert 1 << 30 <= id < 1 << 31

    def test_returns_different_values(self):
        """Retorna valores diferentes."""
        ids = [generate_unique_id() for _ in range(10)]
        assert len(set(ids)) > 5  # Pelo menos alguns diferentes


class TestEscapeHtml:
    """Testes para escape_html."""

    def test_escape_ampersand(self):
        """Escapa & corretamente."""
        assert escape_html("A & B") == "A &amp; B"

    def test_escape_brackets(self):
        """Escapa < e > corretamente."""
        assert escape_html("<script>") == "&lt;script&gt;"

    def test_escape_quotes(self):
        """Escapa aspas corretamente."""
        assert escape_html('"teste"') == "&quot;teste&quot;"

    def test_empty_string(self):
        """Retorna vazio para string vazia."""
        assert escape_html("") == ""
        assert escape_html(None) == ""


class TestTruncateText:
    """Testes para truncate_text."""

    def test_short_text_unchanged(self):
        """Texto curto n√£o √© alterado."""
        text = "Short text"
        assert truncate_text(text, max_length=100) == text

    def test_truncate_long_text(self):
        """Texto longo √© truncado."""
        text = "A" * 200
        result = truncate_text(text, max_length=100)

        assert len(result) == 100
        assert result.endswith("...")

    def test_custom_suffix(self):
        """Usa sufixo customizado."""
        text = "A" * 200
        result = truncate_text(text, max_length=100, suffix="[...]")

        assert result.endswith("[...]")

    def test_empty_text(self):
        """Retorna vazio para texto vazio."""
        assert truncate_text("", max_length=100) == ""
        assert truncate_text(None, max_length=100) == ""
</file>

<file path="tests/test_validators.py">
"""Testes para o m√≥dulo de valida√ß√£o."""

import pytest

from legal_anki.validators import (
    CardValidationError,
    validate_card,
    validate_cards_batch,
)


class TestValidateCard:
    """Testes para validate_card."""

    def test_valid_basic_card(self, sample_card_basic):
        """Card v√°lido deve passar na valida√ß√£o."""
        assert validate_card(sample_card_basic) is True

    def test_invalid_card_short_front(self, sample_card_invalid):
        """Card com front curto deve falhar."""
        with pytest.raises(CardValidationError) as exc_info:
            validate_card(sample_card_invalid)

        assert "Front muito curto" in str(exc_info.value)

    def test_invalid_card_empty_back(self, sample_card_invalid):
        """Card com back vazio deve falhar."""
        with pytest.raises(CardValidationError) as exc_info:
            validate_card(sample_card_invalid)

        assert "Back muito curto" in str(exc_info.value)

    def test_invalid_card_no_tags(self, sample_card_invalid):
        """Card sem tags deve falhar."""
        with pytest.raises(CardValidationError) as exc_info:
            validate_card(sample_card_invalid)

        assert "sem tags" in str(exc_info.value)

    def test_valid_card_without_legal_basis_requirement(self):
        """Card sem fundamento legal √© v√°lido se n√£o exigido."""
        from legal_anki.models import AnkiCard

        card = AnkiCard(
            front="Qual √© a capital do Brasil?",
            back="Bras√≠lia √© a capital federal.",
            card_type="basic",
            tags=["geografia"],
            extra=None,
        )

        # Sem exigir fundamento legal
        assert validate_card(card, require_legal_basis=False) is True

    def test_invalid_card_missing_legal_basis(self):
        """Card sem fundamento legal falha se exigido."""
        from legal_anki.models import AnkiCard

        card = AnkiCard(
            front="Qual √© a capital do Brasil?",
            back="Bras√≠lia √© a capital federal.",
            card_type="basic",
            tags=["geografia"],
            extra=None,
        )

        with pytest.raises(CardValidationError) as exc_info:
            validate_card(card, require_legal_basis=True)

        assert "fundamento legal" in str(exc_info.value)

    def test_valid_card_with_legal_basis_in_back(self):
        """Card com fundamento legal no back √© v√°lido."""
        from legal_anki.models import AnkiCard

        card = AnkiCard(
            front="Qual √© o fundamento do habeas corpus?",
            back="O habeas corpus est√° previsto no Art. 5¬∫, LXVIII, da CF/88.",
            card_type="basic",
            tags=["garantias"],
            extra=None,
        )

        assert validate_card(card, require_legal_basis=True) is True

    def test_cloze_without_deletion_fails(self):
        """Card cloze sem marca√ß√£o de lacuna deve falhar."""
        from legal_anki.models import AnkiCard

        card = AnkiCard(
            front="O STF √© composto por 11 ministros.",  # Sem {{c1::}}
            back="Composi√ß√£o do STF",
            card_type="cloze",
            tags=["stf"],
            extra={"fundamento": "Art. 101, CF"},
        )

        with pytest.raises(CardValidationError) as exc_info:
            validate_card(card)

        assert "cloze sem marca√ß√£o" in str(exc_info.value)

    def test_questao_without_banca_fails(self):
        """Card quest√£o sem banca deve falhar."""
        from legal_anki.models import AnkiCard

        card = AnkiCard(
            front="O direito ao sil√™ncio √© absoluto?",
            back="N√£o, admite exce√ß√µes.",
            card_type="questao",
            tags=["direitos"],
            extra={"fundamento": "Art. 5¬∫, LXIII"},  # Sem banca
        )

        with pytest.raises(CardValidationError) as exc_info:
            validate_card(card)

        assert "sem banca" in str(exc_info.value)


class TestValidateCardsBatch:
    """Testes para validate_cards_batch."""

    def test_all_valid_cards(self, sample_cards):
        """Todos os cards v√°lidos devem passar."""
        valid, errors = validate_cards_batch(sample_cards, skip_invalid=True)

        assert len(valid) == len(sample_cards)
        assert len(errors) == 0

    def test_skip_invalid_cards(self, sample_cards, sample_card_invalid):
        """Cards inv√°lidos s√£o pulados com skip_invalid=True."""
        cards = sample_cards + [sample_card_invalid]

        valid, errors = validate_cards_batch(cards, skip_invalid=True)

        assert len(valid) == len(sample_cards)
        assert len(errors) == 1

    def test_raise_on_invalid_card(self, sample_card_invalid):
        """Deve levantar exce√ß√£o com skip_invalid=False."""
        with pytest.raises(CardValidationError):
            validate_cards_batch([sample_card_invalid], skip_invalid=False)
</file>

<file path=".env.example">
# OpenAI
OPENAI_API_KEY=sk-...
OPENAI_MODEL=gpt-4o-2024-08-06

# Anki IDs (evita conflitos entre perfis)
# Gere novos IDs com: python -c "import random; print(random.randrange(1 << 30, 1 << 31))"
ANKI_DECK_ID=1234567890
ANKI_MODEL_BASIC_ID=1234567891
ANKI_MODEL_CLOZE_ID=1234567892
ANKI_MODEL_QUESTAO_ID=1234567893
ANKI_MODEL_JURISPRUDENCIA_ID=1234567894

# AnkiConnect
ANKI_CONNECT_URL=http://localhost:8765

# Skill Versioning
SKILL_VERSION=1.0.0
</file>

<file path=".python-version">
3.13
</file>

<file path="main.py">
import argparse
import logging
import sys
from pathlib import Path

from legal_anki.exporters import export_to_csv
from legal_anki.generator import generate_cards

# Configura√ß√£o de logging b√°sico para console
logging.basicConfig(
    level=logging.INFO, format="%(levelname)s: %(message)s", stream=sys.stdout
)
logger = logging.getLogger(__name__)


def main():
    parser = argparse.ArgumentParser(
        description="LegalAnki - Gerador de Flashcards Anki para Direito Constitucional",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    # Argumentos
    parser.add_argument("input", help="Texto de origem ou caminho para um arquivo .txt")
    parser.add_argument(
        "--topic",
        required=True,
        help="T√≥pico principal dos cards (ex: controle_constitucional)",
    )
    parser.add_argument(
        "--output",
        default="legal_anki_cards.csv",
        help="Caminho do arquivo CSV de sa√≠da",
    )
    parser.add_argument(
        "--difficulty",
        choices=["facil", "medio", "dificil"],
        default="medio",
        help="N√≠vel de dificuldade dos cards",
    )
    parser.add_argument(
        "--max-cards",
        type=int,
        default=5,
        help="N√∫mero m√°ximo de cards a serem gerados",
    )
    parser.add_argument(
        "--no-legal-basis",
        action="store_false",
        dest="include_legal_basis",
        help="N√£o obriga a inclus√£o de fundamento legal nos cards",
    )
    parser.set_defaults(include_legal_basis=True)

    args = parser.parse_args()

    if args.max_cards < 1:
        parser.error("--max-cards deve ser pelo menos 1")

    # 1. Determina o conte√∫do de entrada
    input_path = Path(args.input)
    if input_path.is_file():
        try:
            content = input_path.read_text(encoding="utf-8")
            logger.info("Lendo conte√∫do do arquivo: %s", args.input)
        except Exception as e:
            logger.error("Erro ao ler arquivo %s: %s", args.input, e, exc_info=True)
            sys.exit(1)
    else:
        content = args.input
        logger.info("Processando texto fornecido diretamente via CLI")

    # 2. Gera os cards via LLM
    logger.info(
        "Iniciando gera√ß√£o de at√© %d cards para o t√≥pico: %s",
        args.max_cards,
        args.topic,
    )
    try:
        cards = generate_cards(
            text=content,
            topic=args.topic,
            difficulty=args.difficulty,
            include_legal_basis=args.include_legal_basis,
            max_cards=args.max_cards,
        )
    except Exception:
        logger.exception("Falha na gera√ß√£o de cards")
        sys.exit(1)

    # 3. Exporta para CSV
    try:
        output_file = export_to_csv(cards, output_path=args.output)
        logger.info("Sucesso! %d cards exportados para: %s", len(cards), output_file)
        print(f"\n‚úÖ Cards gerados com sucesso em: {output_file}")
    except Exception:
        logger.exception("Erro ao exportar cards")
        sys.exit(1)


if __name__ == "__main__":
    main()
</file>

<file path="PRD.md">
# LegalAnki - Documento de Requisitos de Produto (PRD)

| Campo              | Valor              |
| ------------------ | ------------------ |
| Vers√£o             | 1.1.0              |
| Status             | Em Desenvolvimento |
| Respons√°vel        | Gabriel Ramos      |
| √öltima atualiza√ß√£o | 2026-02-08         |

## Hist√≥rico de Revis√µes

| Vers√£o | Data       | Autor         | Descri√ß√£o                                               |
| ------ | ---------- | ------------- | ------------------------------------------------------- |
| 1.0.0  | 2026-02-01 | Equipe        | Vers√£o inicial do PRD                                   |
| 1.1.0  | 2026-02-08 | Gabriel Ramos | Adi√ß√£o de personas, user stories, roadmap e arquitetura |

---

## 1. Vis√£o Geral do Produto

Skill/servi√ßo que recebe conte√∫do jur√≠dico (leis, PDFs de aula, quest√µes, jurisprud√™ncia) e gera automaticamente flashcards Anki otimizados para **Direito Constitucional para concursos**, com export em TSV, JSON e `.apkg`, al√©m de op√ß√£o de envio direto via AnkiConnect.

- **P√∫blico**: concurseiros (OAB, magistratura, MP, delegados), estudantes de Direito e professores.
- **Forma de uso**: embutido em agentes (Context7/MCP), bots (Discord/Telegram) ou scripts locais, recebendo texto e devolvendo cards prontos para Anki.

---

## 2. Personas

### Persona 1: Concurseiro Dedicado

| Atributo    | Detalhes                                           |
| ----------- | -------------------------------------------------- |
| Nome        | Maria, 28 anos                                     |
| Perfil      | Advogada preparando-se para Magistratura Estadual  |
| Dor         | Gasta 4h/dia criando flashcards manualmente        |
| Objetivo    | Automatizar cria√ß√£o de cards de qualidade jur√≠dica |
| Dispositivo | MacBook + Anki Desktop                             |

### Persona 2: Professor de Cursinho

| Atributo    | Detalhes                                        |
| ----------- | ----------------------------------------------- |
| Nome        | Carlos, 45 anos                                 |
| Perfil      | Professor de Direito Constitucional em cursinho |
| Dor         | Preparar material personalizado para cada turma |
| Objetivo    | Gerar decks tem√°ticos rapidamente para alunos   |
| Dispositivo | Windows + integra√ß√£o com plataforma do curso    |

### Persona 3: Estudante de Gradua√ß√£o

| Atributo    | Detalhes                                           |
| ----------- | -------------------------------------------------- |
| Nome        | Jo√£o, 22 anos                                      |
| Perfil      | 5¬∫ per√≠odo de Direito, primeira vez estudando Anki |
| Dor         | Fixar conte√∫do extenso da CF/88 e jurisprud√™ncia   |
| Objetivo    | Cards simples para revis√£o di√°ria no celular       |
| Dispositivo | AnkiDroid no smartphone                            |

---

## 3. Objetivos e Sucesso

### Objetivos Principais

- Automatizar a cria√ß√£o de cards Anki de alta qualidade, reduzindo tempo de prepara√ß√£o de material.
- Garantir cards atomizados, com fundamento legal expl√≠cito e, quando aplic√°vel, jurisprud√™ncia recente do STF/STJ.
- Permitir cria√ß√£o em massa (dezenas/centenas) a partir de uma √∫nica fonte (aula, lei, caderno de quest√µes).

### M√©tricas de Sucesso

| M√©trica                                                  | Meta   |
| -------------------------------------------------------- | ------ |
| Cards aprovados pelo professor sem edi√ß√£o substancial    | ‚â• 80%  |
| Tempo m√©dio para gerar e importar deck de 50 cards       | ‚â§ 5min |
| Cards de jurisprud√™ncia com tese, tribunal e ano         | ‚â• 90%  |
| Taxa de cards v√°lidos (JSON v√°lido, campos obrigat√≥rios) | ‚â• 95%  |

---

## 4. Escopo Funcional

### 4.1 Inclu√≠do (v1)

- Gera√ß√£o de cards a partir de texto bruto (leis, doutrina resumida, quest√µes de concurso, s√∫mulas, informativos).
- **Tipos de card**:
  - `basic` ‚Äì pergunta e resposta diretas
  - `cloze` ‚Äì conceitos, defini√ß√µes, artigos com lacunas
  - `jurisprudencia` ‚Äì tese + tribunal + ano + refer√™ncia
  - `questao_concurso` ‚Äì enunciado, alternativa correta/coment√°rio, fundamento, banca/ano
- Controle de **dificuldade** (`facil`, `medio`, `dificil`, `OAB`, `magistratura`) e **topic** (ex.: "controle de constitucionalidade").
- **Export**:
  - TSV (front, back, tags)
  - JSON (estrutura completa para logs/reprocessamento)
  - `.apkg` base64 via [genanki](https://github.com/kerrickstaley/genanki)
- Integra√ß√£o opcional com [AnkiConnect](https://git.sr.ht/~foosoft/anki-connect) (`addNote`) para enviar cards diretamente ao Anki Desktop.

### 4.2 Fora de Escopo (v1)

- Parsing nativo de PDFs/Word (espera-se texto j√° extra√≠do pelo agente/ferramenta externa)
- Interface gr√°fica pr√≥pria (web/app) ‚Äì uso previsto via CLI, agente ou bot
- Gest√£o de espa√ßamento (scheduling) no lado da skill (delegado ao Anki)

---

## 5. User Stories

### US-001: Gera√ß√£o de Cards via Agente MCP

**Como** concurseiro
**Quero** gerar flashcards a partir de trechos de lei enviados ao agente
**Para** economizar tempo de estudo e manter cards padronizados

**Crit√©rios de Aceita√ß√£o:**

- [ ] Sistema aceita texto de at√© 10.000 caracteres
- [ ] Gera m√≠nimo de 5 cards por requisi√ß√£o
- [ ] Cada card cont√©m fundamento legal quando `include_legal_basis=true`
- [ ] Export em TSV, JSON e APKG dispon√≠vel na resposta
- [ ] Retorno em ‚â§ 15 segundos para 20 cards

### US-002: Integra√ß√£o AnkiConnect

**Como** usu√°rio avan√ßado com Anki Desktop
**Quero** enviar cards diretamente ao meu Anki sem exportar arquivos
**Para** evitar importa√ß√£o manual e manter fluxo cont√≠nuo

**Crit√©rios de Aceita√ß√£o:**

- [ ] Detecta automaticamente se AnkiConnect est√° ativo (porta 8765)
- [ ] Cria deck automaticamente se n√£o existir
- [ ] Mostra confirma√ß√£o de quantos cards foram adicionados
- [ ] Erro amig√°vel se Anki n√£o estiver aberto

### US-003: Cards de Jurisprud√™ncia

**Como** candidato a magistratura
**Quero** cards focados em teses jurisprudenciais do STF/STJ
**Para** memorizar posicionamentos atualizados dos tribunais superiores

**Crit√©rios de Aceita√ß√£o:**

- [ ] Card cont√©m: tese, tribunal, ano, ementa resumida
- [ ] Tag autom√°tica com tribunal e ano (ex.: `stf::2025`)
- [ ] Refer√™ncia completa no campo extra
- [ ] ‚â• 90% de ader√™ncia ao formato

### US-004: Gera√ß√£o via Bot Telegram

**Como** estudante que usa Telegram no dia a dia
**Quero** enviar texto/PDF ao bot e receber `.apkg` pronto
**Para** criar cards durante trajetos e intervalos

**Crit√©rios de Aceita√ß√£o:**

- [ ] Comando `/anki <tema> <dificuldade> <num_cards>`
- [ ] Bot extrai texto se necess√°rio
- [ ] Retorna arquivo `.apkg` para download direto
- [ ] Mensagem de erro clara se falhar

---

## 6. Arquitetura do Sistema

```mermaid
flowchart TD
    subgraph Entrada
        A[Texto/PDF Extra√≠do] --> B[Agente MCP]
        A --> C[Bot Telegram/Discord]
        A --> D[CLI Local]
    end

    subgraph Core LegalAnki
        B --> E[Skill generate_anki_cards]
        C --> E
        D --> E
        E --> F[LLM OpenAI<br/>chat.completions]
        F --> G[Validador JSON<br/>validators.py]
        G --> H[Genanki Builder<br/>exporters.py]
    end

    subgraph Sa√≠da
        H --> I[TSV]
        H --> J[JSON]
        H --> K[APKG Base64]
        E --> L[AnkiConnect<br/>addNote]
    end

    style E fill:#4CAF50,color:#fff
    style F fill:#2196F3,color:#fff
    style L fill:#FF9800,color:#fff
```

### Componentes Principais

| Componente  | Arquivo           | Responsabilidade                            |
| ----------- | ----------------- | ------------------------------------------- |
| Generator   | `generator.py`    | Orquestra fluxo de gera√ß√£o de cards         |
| LLM Client  | `llm/`            | Comunica com OpenAI API                     |
| Validators  | `validators.py`   | Valida estrutura JSON e campos obrigat√≥rios |
| Exporters   | `exporters.py`    | Gera TSV, JSON e APKG via genanki           |
| AnkiConnect | `anki_connect.py` | Integra√ß√£o com Anki Desktop                 |
| Models      | `models.py`       | Defini√ß√£o de dataclasses (Card, Deck, etc.) |
| Config      | `config.py`       | Configura√ß√µes e vari√°veis de ambiente       |

---

## 7. Requisitos Detalhados

### 7.1 Entrada e Par√¢metros

| Par√¢metro             | Tipo                                                           | Descri√ß√£o                                          |
| --------------------- | -------------------------------------------------------------- | -------------------------------------------------- |
| `content`             | `str`                                                          | Bloco de texto com o material de origem            |
| `card_type`           | `"basic" \| "cloze" \| "jurisprudencia" \| "questao_concurso"` | Tipo de card a gerar                               |
| `topic`               | `str`                                                          | Tema para tags e nome do deck                      |
| `difficulty`          | `"facil" \| "medio" \| "dificil" \| "OAB" \| "magistratura"`   | N√≠vel de dificuldade                               |
| `num_cards`           | `int`                                                          | Quantidade-alvo de cards (5‚Äì50)                    |
| `include_legal_basis` | `bool`                                                         | For√ßa inclus√£o de fundamento legal/jurisprudencial |

**Regras de comportamento:**

- Se `include_legal_basis=true`, cada card deve conter pelo menos um fundamento legal (artigo, s√∫mula, tese) no campo `back` ou `extra.fundamento`.
- `topic` e `difficulty` geram tags normalizadas (min√∫sculas, sem acentos e espa√ßos).

### 7.2 Sa√≠da

Objeto JSON com:

```json
{
  "cards": [
    {
      "front": "Qual o prazo da ADI?",
      "back": "N√£o h√° prazo. Art. 103, CF/88. üìö",
      "tags": ["direito-constitucional", "controle-concentrado", "medio"],
      "extra": {
        "fundamento": "Art. 103, CF/88",
        "dificuldade": "medio"
      }
    }
  ],
  "exports": {
    "tsv": "front\tback\ttags\n...",
    "json": "{...}",
    "apkg": "UEsDBBQAAAAI..."
  },
  "metadata": {
    "total": 20,
    "deck_name": "Direito Constitucional - Controle de Constitucionalidade",
    "tags_used": ["direito-constitucional", "controle-concentrado"],
    "skill_version": "1.1.0",
    "llm_model": "gpt-4o-mini"
  }
}
```

### 7.3 Templates e Modelos Anki

| Modelo                   | Campos                                                    |
| ------------------------ | --------------------------------------------------------- |
| Quest√£o Concurso Direito | Enunciado, Resposta, Fundamento, Banca (layout HTML/CSS)  |
| Jurisprud√™ncia           | Tese, Tribunal, Ano, Ementa_Resumida, Referencia_Completa |
| Cloze Constitucional     | Text (com sintaxe `{{c1::...}}`)                          |

- Mapeamento de `Card.extra` ‚Üí campos do modelo sempre que o modelo tiver mais que `Front/Back`.

### 7.4 LLM / Prompt

- **Gera√ß√£o Estruturada**: Utiliza a funcionalidade de _Structured Outputs_ da OpenAI (`client.beta.chat.completions.parse`) para garantir que os cards sigam rigorosamente o esquema JSON definido em modelos Pydantic (`AnkiCard`), eliminando erros de parsing.
  - Regras de atomiza√ß√£o (um conceito por card, respostas objetivas)
  - √änfase em literalidade da CF/88 e jurisprud√™ncia atual STF/STJ
  - Exemplos de cards v√°lidos (basic, cloze, jurisprud√™ncia, quest√£o)

---

## 8. Requisitos N√£o Funcionais

| Categoria           | Requisito                                                                          |
| ------------------- | ---------------------------------------------------------------------------------- |
| **Performance**     | Gerar 20 cards em ‚â§ 15 segundos (rede est√°vel, modelo remoto)                      |
| **Confiabilidade**  | Valida√ß√£o p√≥s-LLM (campos obrigat√≥rios, JSON v√°lido, quantidade m√≠nima) + fallback |
| **Observabilidade** | Logs de entradas (anonimizadas), par√¢metros usados e contagem de tokens/custos     |
| **Extensibilidade** | F√°cil inclus√£o de novos `card_type` e suporte a outras √°reas do Direito            |
| **Seguran√ßa**       | Nenhuma persist√™ncia de conte√∫do sens√≠vel; chaves de API via vari√°veis de ambiente |

---

## 9. Fluxos Principais de Uso

### Fluxo 1 ‚Äì Professor/Concurseiro via Agente (Context7/MCP)

```mermaid
sequenceDiagram
    participant U as Usu√°rio
    participant A as Agente MCP
    participant S as Skill LegalAnki
    participant L as OpenAI LLM
    participant G as Genanki

    U->>A: Envia trecho de lei + par√¢metros
    A->>S: generate_anki_cards()
    S->>L: chat.completions (JSON mode)
    L-->>S: JSON com cards
    S->>S: Valida estrutura
    S->>G: Gera .apkg
    G-->>S: APKG base64
    S-->>A: JSON + exports
    A-->>U: Link/download do .apkg ou TSV
```

### Fluxo 2 ‚Äì Integra√ß√£o AnkiConnect

1. Usu√°rio executa script local com Anki aberto e AnkiConnect ativado.
2. Script chama `generate_cards`, obt√©m `cards`.
3. Para cada card, envia `addNote` para AnkiConnect com `deckName` e `modelName` apropriados.
4. Cards aparecem imediatamente no deck do Anki, sem precisar de import manual.

### Fluxo 3 ‚Äì Bot Discord/Telegram

1. Usu√°rio envia PDF/lei/quest√µes para o bot com comando `/anki constitucional magistratura 30 cards`.
2. Bot extrai texto, chama skill, recebe `.apkg`.
3. Bot envia arquivo `.apkg` pronto para download.

---

## 10. Matriz de Prioriza√ß√£o (MoSCoW)

### Must Have (Essencial para v1)

- [x] Gera√ß√£o de cards `basic` e `cloze`
- [x] Export JSON e TSV
- [x] Valida√ß√£o de estrutura JSON
- [x] Integra√ß√£o OpenAI com JSON mode
- [ ] Export APKG via genanki

### Should Have (Importante)

- [ ] Tipo `jurisprudencia` completo
- [ ] Tipo `questao_concurso`
- [ ] Integra√ß√£o AnkiConnect
- [ ] Tags normalizadas autom√°ticas

### Could Have (Desej√°vel)

- [ ] M√©tricas de qualidade dos cards
- [ ] Templates Anki personaliz√°veis
- [ ] Cache de prompts otimizados
- [ ] Suporte a m√∫ltiplos modelos LLM

### Won't Have (v1)

- Interface gr√°fica pr√≥pria
- Parsing de PDF nativo
- Scheduling de revis√µes
- Sincroniza√ß√£o com AnkiWeb

---

## 11. Roadmap

### Fase 1: MVP (v1.0) ‚úÖ

- [x] Gera√ß√£o de cards b√°sicos e cloze
- [x] Export TSV e JSON
- [x] Integra√ß√£o OpenAI
- [x] Valida√ß√£o de estrutura JSON
- [x] Modelos de dados (dataclasses)

### Fase 2: Produ√ß√£o (v1.1) üîÑ

- [ ] Gera√ß√£o de APKG via genanki
- [ ] Tipo jurisprud√™ncia completo
- [ ] Tipo quest√£o de concurso
- [ ] Integra√ß√£o AnkiConnect
- [ ] Testes automatizados (pytest)

### Fase 3: Expans√£o (v2.0) üìã

- [ ] Suporte a Direito Administrativo
- [ ] Suporte a Direito Penal
- [ ] Templates personaliz√°veis
- [ ] M√©tricas de qualidade dos cards
- [ ] Dashboard de uso e custos

---

## 12. Restri√ß√µes, Depend√™ncias e Riscos

### Depend√™ncias

| Depend√™ncia  | Tipo       | Impacto                                 |
| ------------ | ---------- | --------------------------------------- |
| OpenAI API   | Externa    | Lat√™ncia, custos, limites de tokens     |
| genanki      | Biblioteca | Gera√ß√£o de arquivos APKG                |
| AnkiConnect  | Plugin     | Integra√ß√£o direta (opcional)            |
| Python 3.11+ | Runtime    | Compatibilidade de dataclasses e typing |

### Riscos e Mitiga√ß√µes

| Risco                                     | Probabilidade | Impacto | Mitiga√ß√£o                                                |
| ----------------------------------------- | ------------- | ------- | -------------------------------------------------------- |
| Mudan√ßa em modelos LLM afetando qualidade | M√©dia         | Alto    | Exemplos no prompt + versionamento de prompts            |
| Alucina√ß√µes de fundamentos legais         | Alta          | M√©dio   | Checks autom√°ticos (regex "Art. X, CF") + revis√£o humana |
| Rate limits da OpenAI                     | Baixa         | M√©dio   | Retry com backoff exponencial                            |
| AnkiConnect indispon√≠vel                  | Baixa         | Baixo   | Fallback para export APKG                                |

---

## 13. Gloss√°rio

| Termo              | Defini√ß√£o                                                                |
| ------------------ | ------------------------------------------------------------------------ |
| **Card**           | Unidade de flashcard com frente (pergunta) e verso (resposta)            |
| **Cloze**          | Tipo de card com lacunas para preenchimento (ex: `{{c1::texto}}`)        |
| **Deck**           | Conjunto de cards agrupados por tema                                     |
| **APKG**           | Formato de pacote Anki para importa√ß√£o/exporta√ß√£o de decks               |
| **AnkiConnect**    | Plugin que exp√µe API REST para controle do Anki Desktop                  |
| **Genanki**        | Biblioteca Python para gera√ß√£o program√°tica de arquivos APKG             |
| **MCP**            | Model Context Protocol ‚Äì padr√£o para integra√ß√£o de skills com agentes IA |
| **Atomiza√ß√£o**     | Princ√≠pio de criar cards com um √∫nico conceito por unidade               |
| **Jurisprud√™ncia** | Entendimento dos tribunais sobre determinada mat√©ria                     |
| **S√∫mula**         | Enunciado que resume jurisprud√™ncia dominante de um tribunal             |

---

## 14. Refer√™ncias

### Documenta√ß√£o T√©cnica

- [genanki - GitHub](https://github.com/kerrickstaley/genanki) ‚Äì Biblioteca para gera√ß√£o de APKG
- [AnkiConnect - SourceHut](https://git.sr.ht/~foosoft/anki-connect) ‚Äì Plugin de API REST para Anki
- [OpenAI Chat Completions - JSON Mode](https://community.openai.com/t/how-do-i-use-the-new-json-mode/475890) ‚Äì Documenta√ß√£o do modo JSON

### Metodologia PRD

- [PRD Templates and Examples - AltexSoft](https://www.altexsoft.com/blog/product-requirements-document/)
- [Product Requirements Document - Product School](https://productschool.com/blog/product-strategy/product-template-requirements-document-prd)
- [Documento de Requisitos de Produto - Banani](https://www.banani.co/pt/blog/what-is-prd-product-requirements-document)
- [PRD Template - Inflectra](https://www.inflectra.com/Ideas/Topic/PRD-Template.aspx)
- [Template de PRD - Monday.com](https://monday.com/blog/pt/desenvolvimento/template-de-prd/)
</file>

<file path="pyproject.toml">
[project]
name = "legal-anki"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = ">=3.13"
dependencies = [
    "genanki>=0.13.1",
    "openai>=2.17.0",
    "pydantic>=2.12.5",
    "pydantic-settings>=2.12.0",
    "python-dotenv>=1.2.1",
    "requests>=2.32.5",
    "tenacity>=9.1.4",
]

[dependency-groups]
dev = [
    "pytest>=9.0.2",
    "pytest-asyncio>=1.3.0",
    "pytest-cov>=7.0.0",
]
</file>

<file path="README.md">
# LegalAnki üìö‚öñÔ∏è

<div align="center">

**Gerador inteligente de flashcards Anki para Direito Constitucional usando LLM**

[![Python](https://img.shields.io/badge/Python-3.13+-blue.svg)](https://www.python.org/downloads/)
[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)
[![License](https://img.shields.io/badge/license-MIT-green.svg)](LICENSE)

</div>

## Vis√£o Geral

LegalAnki √© uma skill/biblioteca Python que transforma conte√∫do jur√≠dico (leis, PDFs de aula, quest√µes, jurisprud√™ncia) em flashcards Anki otimizados para **Direito Constitucional em concursos**.

### Principais Recursos

- ü§ñ **Gera√ß√£o via LLM** ‚Äì OpenAI GPT-4o com Structured Outputs
- üìù **M√∫ltiplos tipos de card** ‚Äì Basic, Cloze, Quest√£o de Concurso, Jurisprud√™ncia
- üì¶ **Exports flex√≠veis** ‚Äì CSV, TSV, JSON, APKG (`.apkg`)
- üîó **Integra√ß√£o AnkiConnect** ‚Äì Envio direto para o Anki Desktop
- ‚ö° **Valida√ß√£o autom√°tica** ‚Äì Estrutura JSON e campos obrigat√≥rios

---

## Quick Start

### 1. Instala√ß√£o

```bash
# Clone o reposit√≥rio
git clone https://github.com/seu-usuario/LegalAnki.git
cd LegalAnki

# Instale as depend√™ncias com uv
uv sync

# Ou com pip
pip install -e .
```

### 2. Configura√ß√£o

Copie o arquivo de exemplo e configure sua API key:

```bash
cp .env.example .env
```

Edite `.env` com sua chave OpenAI:

```env
OPENAI_API_KEY=sk-...
```

### 3. Uso B√°sico

```python
from legal_anki.generator import generate_cards
from legal_anki.exporters import export_to_apkg

# Gerar cards a partir de texto
cards = generate_cards(
    text="Art. 5¬∫, CF/88: Todos s√£o iguais perante a lei...",
    topic="direitos_fundamentais",
    difficulty="medio",
    max_cards=5
)

# Exportar para APKG
export_to_apkg(cards, deck_name="Direito Constitucional", output_path="deck.apkg")
```

### 4. Via CLI

```bash
uv run python main.py
```

---

## Vari√°veis de Ambiente

| Vari√°vel                       | Obrigat√≥ria | Descri√ß√£o                   | Exemplo                 |
| ------------------------------ | ----------- | --------------------------- | ----------------------- |
| `OPENAI_API_KEY`               | ‚úÖ          | Chave da API OpenAI         | `sk-...`                |
| `OPENAI_MODEL`                 | ‚ùå          | Modelo a usar               | `gpt-4o-2024-08-06`     |
| `ANKI_DECK_ID`                 | ‚ùå          | ID √∫nico do deck            | `1234567890`            |
| `ANKI_MODEL_BASIC_ID`          | ‚ùå          | ID do modelo Basic          | `1234567891`            |
| `ANKI_MODEL_CLOZE_ID`          | ‚ùå          | ID do modelo Cloze          | `1234567892`            |
| `ANKI_MODEL_QUESTAO_ID`        | ‚ùå          | ID do modelo Quest√£o        | `1234567893`            |
| `ANKI_MODEL_JURISPRUDENCIA_ID` | ‚ùå          | ID do modelo Jurisprud√™ncia | `1234567894`            |
| `ANKI_CONNECT_URL`             | ‚ùå          | URL do AnkiConnect          | `http://localhost:8765` |

> **Nota**: Os IDs Anki evitam conflitos entre perfis. Gere novos IDs com:
>
> ```bash
> python -c "import random; print(random.randrange(1 << 30, 1 << 31))"
> ```

---

## üìñ Exemplos de Uso

### Exemplo 1: Cards a partir de Artigo da CF/88

```python
from legal_anki.generator import generate_cards
from legal_anki.exporters import export_to_apkg

artigo = """
Art. 5¬∫, LXIII - a plenitude da defesa;
Art. 5¬∫, LXIV - o direito de informar, aos seus familiares e √†s
pessoas que lhe s√£o pr√≥ximas, sobre sua pris√£o ou deten√ß√£o;
Art. 5¬∫, LXV - a pris√£o de qualquer pessoa e o local onde se
encontre ser√£o comunicados imediatamente ao juiz competente
e √† fam√≠lia do preso ou √† pessoa por ele indicada.
"""

cards = generate_cards(
    text=artigo,
    topic="garantias_processuais",
    difficulty="medio",
    card_type="cloze",
    max_cards=10
)

export_to_apkg(cards, "Garantias Processuais.apkg")
```

### Exemplo 2: Cards de Jurisprud√™ncia

```python
from legal_anki.generator import generate_cards
from legal_anki.exporters import export_to_csv

sumula = """
S√∫mula Vinculante 11 - STF: S√≥ √© l√≠cito o uso de algemas em casos
de resist√™ncia e de fundado receio de fuga ou de perigo √†
integridade f√≠sica pr√≥pria ou alheia, por parte do preso ou de
terceiros, devendo justificar a excepcionalidade por escrito.
"""

cards = generate_cards(
    text=sumula,
    topic="sumulas_vinculantes",
    difficulty="dificil",
    card_type="jurisprudencia"
)

# Exporta para CSV com cabe√ßalho
export_to_csv(cards, "sumulas.csv", include_header=True)
```

### Exemplo 3: M√∫ltiplos Formatos

```python
from legal_anki.generator import generate_cards
from legal_anki.exporters import export_cards

cards = generate_cards(
    text="Art. 5¬∫ da CF/88...",
    topic="direitos_fundamentais"
)

# Exporta para todos os formatos
for fmt in ["csv", "json", "apkg"]:
    export_cards(
        cards=cards,
        output_path=f"direitos_fundamentais.{fmt}",
        format=fmt,
        deck_name="Direito Constitucional"  # apenas para APKG
    )
```

### Exemplo 4: Integra√ß√£o com AnkiConnect

```python
from legal_anki.anki_connect import AnkiConnectClient
from legal_anki.generator import generate_cards

client = AnkiConnectClient()

# Verifica se Anki est√° rodando
if client.is_available():
    cards = generate_cards(text=texto, topic="teste")

    # Adiciona cards ao deck
    for card in cards:
        note_id = client.add_card(
            card=card,
            deck_name="LegalAnki::Teste"
        )
        print(f"Card adicionado: {note_id}")

    # Sincroniza com AnkiWeb
    client.sync()
else:
    print("Abra o Anki com AnkiConnect instalado")
```

---

## Arquitetura

```mermaid
flowchart LR
    subgraph Entrada
        A[Texto/PDF] --> B[Agente MCP]
        A --> C[Bot Telegram]
        A --> D[CLI]
    end

    subgraph Core
        B --> E[generator.py]
        C --> E
        D --> E
        E --> F[OpenAI LLM]
        F --> G[validators.py]
        G --> H[exporters.py]
    end

    subgraph Sa√≠da
        H --> I[CSV/TSV]
        H --> J[JSON]
        H --> K[APKG]
        E --> L[AnkiConnect]
    end
```

---

## Estrutura do Projeto

```text
LegalAnki/
‚îú‚îÄ‚îÄ src/legal_anki/
‚îÇ   ‚îú‚îÄ‚îÄ generator.py      # Orquestra gera√ß√£o de cards
‚îÇ   ‚îú‚îÄ‚îÄ models.py         # Modelos Anki (genanki)
‚îÇ   ‚îú‚îÄ‚îÄ exporters.py      # CSV, TSV, JSON, APKG
‚îÇ   ‚îú‚îÄ‚îÄ validators.py     # Valida√ß√£o de estrutura
‚îÇ   ‚îú‚îÄ‚îÄ config.py         # Configura√ß√µes
‚îÇ   ‚îú‚îÄ‚îÄ anki_connect.py   # Integra√ß√£o AnkiConnect
‚îÇ   ‚îú‚îÄ‚îÄ llm/              # Cliente OpenAI
‚îÇ   ‚îî‚îÄ‚îÄ prompts/          # System prompts
‚îú‚îÄ‚îÄ tests/                # Testes pytest
‚îú‚îÄ‚îÄ main.py               # Entry point CLI
‚îî‚îÄ‚îÄ PRD.md                # Documento de requisitos
```

---

## Tipos de Card

| Tipo             | Descri√ß√£o                 | Campos                                                       |
| ---------------- | ------------------------- | ------------------------------------------------------------ |
| `basic`          | Pergunta/Resposta simples | Front, Back                                                  |
| `cloze`          | Lacunas para preencher    | Text, Extra                                                  |
| `questao`        | Quest√£o de concurso       | Front, Back, Banca, Ano, Cargo, Fundamento                   |
| `jurisprudencia` | S√∫mulas e julgados        | Front, Back, Tribunal, DataJulgamento, Tema, FundamentoLegal |

---

## Formatos de Export

### CSV (Default)

Separador `;` para compatibilidade com Excel BR.

```csv
front;back;tags
"Qual o prazo da ADI?";"N√£o h√° prazo. Art. 103, CF/88";"controle-concentrado,medio"
```

### TSV

Compat√≠vel com importa√ß√£o direta no Anki.

### JSON

Estrutura completa com metadata para logs e reprocessamento.

### APKG

Pacote Anki pronto para importa√ß√£o via `genanki`.

---

## üß™ Desenvolvimento

### Executando Testes

```bash
# Instale depend√™ncias de desenvolvimento
pip install -e ".[dev]"

# Execute os testes
pytest tests/ -v

# Com cobertura
pytest tests/ --cov=src/legal_anki --cov-report=html

# Teste espec√≠fico
pytest tests/test_utils.py -v
```

### Formata√ß√£o e Lint

```bash
# Black (formata√ß√£o)
black src/ tests/

# isort (ordena√ß√£o de imports)
isort src/ tests/

# ruff (lint r√°pido)
ruff check src/ tests/

# mypy (type checking)
mypy src/legal_anki/
```

### Estrutura de Testes

```text
tests/
‚îú‚îÄ‚îÄ conftest.py           # Fixtures compartilhadas
‚îú‚îÄ‚îÄ test_exporters.py     # Testes de exporta√ß√£o
‚îú‚îÄ‚îÄ test_llm_client.py    # Testes do cliente LLM
‚îú‚îÄ‚îÄ test_utils.py         # Testes de utilit√°rios
‚îî‚îÄ‚îÄ test_validators.py    # Testes de valida√ß√£o
```

---

## ü§ù Contribuindo

Contribui√ß√µes s√£o bem-vindas! Por favor:

1. **Fork** o projeto
2. Crie uma **branch** para sua feature (`git checkout -b feature/nova-feature`)
3. **Commit** suas mudan√ßas (`git commit -m 'Adiciona nova feature'`)
4. **Push** para a branch (`git push origin feature/nova-feature`)
5. Abra um **Pull Request**

### Diretrizes

- Siga PEP 8 para estilo de c√≥digo
- Adicione testes para novas funcionalidades
- Atualize a documenta√ß√£o quando necess√°rio
- Use docstrings Google style

---

## üìÑ Licen√ßa

MIT License - veja [LICENSE](LICENSE) para detalhes.

---

## üôã Suporte

- üìß Abra uma [issue](https://github.com/seu-usuario/LegalAnki/issues) para bugs ou sugest√µes
- üìñ Consulte o [PRD.md](PRD.md) para documenta√ß√£o detalhada dos requisitos
- üí¨ Para discuss√µes sobre Direito Constitucional, consulte materiais especializados

---

## üéØ Sobre o Projeto

Desenvolvido com ‚ù§Ô∏è para concurseiros de Direito Constitucional
</file>

</files>
